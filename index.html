<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <link rel="icon" type="image/x-icon" href="favicon.ico">
    <title>Tenshon Timer</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Bangers&family=Caveat&family=Inter:wght@400;800&family=JetBrains+Mono:wght@700&family=Lobster&family=Orbitron:wght@700&family=Oswald:wght@500&family=Pacifico&family=Playfair+Display:wght@700&family=Press+Start+2P&family=Roboto:wght@400;700&display=swap');

        :root {
            --bg-color: #3498db;
            --text-color: #ffffff;
            --panel-bg: rgba(20, 20, 20, 0.95); 
            --panel-text: #ffffff;
            --inner-panel-bg: rgba(255, 255, 255, 0.1); 
            --input-bg: rgba(0, 0, 0, 0.2);
            --accent: #3498db;
            --bg-blend: overlay;
            --current-font: 'Inter', sans-serif;
            --guide-color: #ff00ff;
        }

        body {
            margin: 0;
            height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-color: var(--bg-color);
            background-repeat: repeat;
            background-position: center;
            background-blend-mode: var(--bg-blend);
            color: var(--text-color);
            font-family: var(--current-font);
            transition: background-color 0.5s ease, color 0.5s ease;
            text-align: center;
            overflow: hidden;
            user-select: none;
            -webkit-user-select: none;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }

        body.custom-image-mode { background-repeat: no-repeat !important; }

        .container {
            position: absolute;
            top: 0; left: 0;
            z-index: 50; /* Default high, managed by JS now */
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            transition: gap 0.3s ease;
            pointer-events: none; /* Allows clicking through empty space */
        }
        
        .container > * { pointer-events: auto; }
        
        /* LOCK LOGIC FOR CONTAINER */
        .container.locked > * { pointer-events: none !important; }

        /* --- LAYOUT MODES --- */
        body.layout-inverted .container { flex-direction: column-reverse; }
        
        body.layout-split .container { flex-direction: row; gap: 5vw; padding: 0 5vw; box-sizing: border-box;}
        body.layout-split .timer-display { font-size: 15vw; }
        body.layout-split h1 { text-align: right; }
        
        body.layout-split-rev .container { flex-direction: row-reverse; gap: 5vw; padding: 0 5vw; box-sizing: border-box;}
        body.layout-split-rev .timer-display { font-size: 15vw; }
        body.layout-split-rev h1 { text-align: left; }

        @media (max-width: 768px) {
            body.layout-split .container, body.layout-split-rev .container { 
                flex-direction: column !important; 
                gap: 0;
            }
            body.layout-split .timer-display, body.layout-split-rev .timer-display { 
                font-size: 22vw; 
            }
            body.layout-split h1, body.layout-split-rev h1 { text-align: center; }
        }

        /* --- WIDGET LAYER --- */
        #widgetLayer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            z-index: auto; 
            pointer-events: none; 
            overflow: hidden;
        }

        .widget {
            position: absolute;
            cursor: grab;
            user-select: none;
            touch-action: none;
            transform-origin: center center;
            display: flex; justify-content: center; align-items: center;
            pointer-events: auto; 
            box-sizing: border-box;
            min-width: 20px; min-height: 20px;
        }
        .widget:active { cursor: grabbing; }
        
        /* LOCKED WIDGET STYLE */
        .widget.locked { pointer-events: none !important; }

        .widget img {
            width: 100%; height: 100%;
            object-fit: contain;
            pointer-events: none;
            display: block;
        }

        .widget-text-content {
            font-size: 50px; /* Base size, overridden by JS */
            white-space: pre-wrap; /* Allow multiline and wrapping */
            font-weight: bold;
            text-shadow: 0 2px 5px rgba(0,0,0,0.3);
            pointer-events: none;
            line-height: 1;
            outline: none;
            min-width: 30px;
        }
        
        /* EDIT MODE STYLES */
        .widget-text-content[contenteditable="true"] {
            pointer-events: auto;
            cursor: text;
            background: rgba(0,0,0,0.2);
            border-radius: 4px;
            padding: 2px 5px;
            border: 1px dashed rgba(255,255,255,0.5);
        }

        .widget.active { outline: 2px dashed rgba(255,255,255,0.8); }
        
        .widget-controls {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; display: none;
        }
        .widget.active .widget-controls { display: block; }

        .w-handle {
            position: absolute; width: 20px; height: 20px;
            background: #3498db; border: 2px solid #fff; border-radius: 50%;
            pointer-events: auto; box-shadow: 0 2px 5px rgba(0,0,0,0.3);
            z-index: 30;
        }
        
        .w-resize { bottom: -10px; right: -10px; cursor: nwse-resize; }
        
        .w-rotate {
            top: -30px; left: 50%; transform: translateX(-50%);
            background: #2ecc71; cursor: grab;
        }
        .w-rotate:active { cursor: grabbing; }
        .w-rotate::after {
            content: ''; position: absolute; top: 20px; left: 8px;
            width: 2px; height: 10px; background: rgba(255,255,255,0.5);
        }

        .w-delete {
            position: absolute; top: -10px; left: -10px;
            width: 20px; height: 20px;
            background: #e74c3c; color: white; border-radius: 50%;
            display: flex; justify-content: center; align-items: center;
            font-size: 14px; font-weight: bold; cursor: pointer;
            pointer-events: auto; border: 2px solid #fff;
        }

        /* --- SNAP GUIDES --- */
        .guide-line {
            position: absolute;
            background-color: var(--guide-color);
            display: none;
            pointer-events: none;
            z-index: 9999; /* Always on top */
            box-shadow: 0 0 5px var(--guide-color);
        }
        .guide-v { width: 1px; height: 100%; top: 0; left: 50%; transform: translateX(-50%); }
        .guide-h { height: 1px; width: 100%; top: 50%; left: 0; transform: translateY(-50%); }

        /* --- ELECTRICITY ANIMATION --- */
        @keyframes electric-change {
            0% { text-shadow: 0 0 0 rgba(0, 255, 255, 0); transform: translate(0,0); }
            10% { text-shadow: 0 0 10px rgba(0, 255, 255, 0.8), 0 0 20px rgba(0, 255, 255, 0.6); color: #fff; transform: translate(-1px, 1px); }
            25% { text-shadow: 0 0 15px rgba(0, 255, 255, 1), 0 0 30px rgba(0, 255, 255, 0.8); color: #e0ffff; transform: translate(2px, -1px); }
            40% { text-shadow: 0 0 5px rgba(0, 255, 255, 0.6); color: #fff; transform: translate(-2px, 0); }
            60% { text-shadow: 0 0 10px rgba(0, 255, 255, 0.4); transform: translate(1px, 2px); }
            100% { text-shadow: 0 4px 8px rgba(0,0,0,0.2); color: var(--text-color); transform: translate(0,0); }
        }

        .glitch-active { animation: electric-change 0.5s ease-out both; }

        /* Scramble Text */
        .scramble-display {
            font-family: 'JetBrains Mono', monospace;
            font-size: 3vh; 
            margin-bottom: 2vh;
            max-width: 95%;
            line-height: 1.2;
            display: none;
            opacity: 0.9;
            font-weight: bold;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
            pointer-events: none;
            text-align: center;
            word-wrap: break-word;
        }
        
        /* Stats / Last Solves List */
        .stats-container {
            display: none;
            flex-direction: column;
            gap: 10px;
            margin-top: 3vh;
            width: 85%;
            max-height: 25vh;
            overflow-y: auto;
            pointer-events: none;
        }

        .stat-item {
            background: rgba(0, 0, 0, 0.3);
            padding: 8px 15px;
            border-radius: 12px;
            text-shadow: 0 1px 2px rgba(0,0,0,0.5);
            text-align: left;
            display: flex;
            flex-direction: column;
            animation: slideIn 0.3s ease-out;
        }

        @keyframes slideIn { from { opacity: 0; transform: translateY(-10px); } to { opacity: 1; transform: translateY(0); } }

        .stat-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 4px;
        }

        .stat-time {
            font-family: 'JetBrains Mono', monospace;
            font-size: 2.2vh;
            color: #2ecc71;
            font-weight: bold;
        }

        .stat-index {
            font-size: 1.5vh;
            opacity: 0.6;
            font-weight: bold;
        }

        .stat-scramble {
            font-family: 'JetBrains Mono', monospace;
            font-size: 1.4vh;
            color: rgba(255, 255, 255, 0.8);
            word-wrap: break-word;
            line-height: 1.1;
        }

        /* POMODORO STATUS */
        .pomo-status {
            font-family: 'JetBrains Mono', monospace;
            font-size: 1rem;
            text-transform: uppercase;
            letter-spacing: 2px;
            background: rgba(255,255,255,0.2);
            padding: 5px 15px;
            border-radius: 20px;
            margin-bottom: 2vh;
            display: none;
            backdrop-filter: blur(5px);
            font-weight: bold;
            animation: fadeIn 0.5s ease;
        }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }

        /* WORLD CLOCK */
        .world-clock-container {
            display: none;
            flex-direction: column;
            align-items: center;
            width: 100%;
            max-height: 80vh;
            overflow-y: auto;
        }
        
        .local-time-wrapper {
            margin-bottom: 20px;
        }
        .local-time {
            font-size: 13vw; 
            font-weight: bold;
            line-height: 1;
            text-shadow: 0 4px 8px rgba(0,0,0,0.2);
            font-variant-numeric: tabular-nums;
        }
        .local-date {
            font-size: 4vw;
            opacity: 0.8;
            margin-top: 5px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        
        .cities-grid {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 15px;
            width: 90%;
            max-width: 1000px;
        }
        
        .city-card {
            background: rgba(0,0,0,0.3);
            backdrop-filter: blur(5px);
            padding: 10px 20px;
            border-radius: 10px;
            min-width: 140px; 
            text-align: center;
            border: 1px solid rgba(255,255,255,0.1);
        }
        .city-name { font-size: 0.8rem; opacity: 0.7; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 5px; }
        .city-time { font-size: 1.2rem; font-weight: bold; font-variant-numeric: tabular-nums; }
        .city-date { font-size: 0.6rem; opacity: 0.5; }

        h1 {
            font-size: 5vw;
            margin: 0;
            outline: none;
            border: 1px solid transparent;
            cursor: text;
            display: none;
            padding: 0 10px;
            border-radius: 10px;
            line-height: 1.2;
            width: 80%;
            max-width: 90%; 
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
            font-family: inherit;
            white-space: pre-wrap; 
            word-wrap: break-word;
            user-select: text;
            -webkit-user-select: text;
            pointer-events: auto;
            transition: opacity 0.3s ease, transform 0.3s ease;
        }
        
        h1.lyric-fade-out { opacity: 0; transform: translateY(-5px); }
        h1.lyric-fade-in { opacity: 1; transform: translateY(0); }

        h1.solo-mode { font-size: 10vw; display: block; }
        h1:hover { background: rgba(255,255,255,0.1); }
        h1:focus { background: rgba(255,255,255,0.2); border-bottom: 2px solid var(--text-color); }

        /* --- TIMER --- */
        .timer-display {
            font-weight: bold;
            font-variant-numeric: tabular-nums; 
            cursor: text; 
            line-height: 1;
            outline: none;
            border-bottom: 2px solid transparent;
            display: inline-block;
            transition: font-size 0.3s ease, color 0.1s;
            text-shadow: 0 4px 8px rgba(0,0,0,0.2);
            font-family: inherit;
            white-space: nowrap; 
            user-select: text;
            -webkit-user-select: text;
            pointer-events: auto;
            font-size: 22vw; 
        }

        /* CUBER MODE COLORS - FIXED */
        .timer-display.cuber-holding { 
            color: #2ecc71 !important; /* GREEN */
            transition: none !important;
        }
        .timer-display.cuber-stopped { 
            color: #e74c3c !important; /* RED */
            transition: none !important;
        }

        .timer-display.ms-mode { font-size: 14vw; }

        body.retro-mode h1 { font-size: 3vw !important; }
        body.retro-mode .timer-display { font-size: 15vw !important; letter-spacing: -2px; }
        body.retro-mode .timer-display.ms-mode { font-size: 9vw !important; letter-spacing: -3px; }
        body.retro-mode .local-time { font-size: 8vw !important; }

        body.fullscreen-mode .timer-display { font-size: 30vw; }
        body.fullscreen-mode .timer-display.ms-mode { font-size: 18vw !important; }
        body.fullscreen-mode.retro-mode .timer-display { font-size: 20vw !important; }
        body.fullscreen-mode.retro-mode .timer-display.ms-mode { font-size: 12vw !important; }

        /* --- DRAGGABLE SETTINGS PANEL --- */
        .settings-panel {
            position: fixed;
            top: 15%;
            left: 5%;
            width: 350px;
            height: 600px;
            background-color: var(--panel-bg); 
            color: var(--panel-text);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-radius: 15px;
            display: flex;
            flex-direction: column;
            box-shadow: 0 20px 50px rgba(0,0,0,0.7);
            z-index: 1000;
            border: 1px solid rgba(128, 128, 128, 0.4); 
            font-family: 'Segoe UI', sans-serif;
            resize: both; 
            overflow: hidden;
            min-width: 300px;
            min-height: 400px;
            max-width: 90vw;
            max-height: 90vh;
        }

        .settings-panel.hidden { opacity: 0; pointer-events: none; transform: scale(0.95); transition: opacity 0.2s, transform 0.2s; }
        
        .panel-header {
            padding: 12px 15px;
            background: var(--inner-panel-bg); 
            cursor: grab;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: bold;
            border-bottom: 1px solid rgba(128,128,128,0.3);
            flex-shrink: 0;
            font-size: 1rem;
            letter-spacing: 0.5px;
        }
        .panel-header:active { cursor: grabbing; }

        .close-btn { background: none; border: none; font-size: 1.2rem; cursor: pointer; color: inherit; padding: 0 8px; transition: color 0.2s; }
        .close-btn:hover { color: #ff5555; }

        .panel-content {
            padding: 15px;
            overflow-y: auto;
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        .panel-content::-webkit-scrollbar { width: 6px; }
        .panel-content::-webkit-scrollbar-thumb { background: rgba(128,128,128,0.5); border-radius: 3px; }

        .settings-section {
            background: var(--inner-panel-bg); 
            padding: 10px;
            border-radius: 8px;
            border: 1px solid rgba(128,128,128,0.1);
        }

        .section-title {
            text-transform: uppercase; letter-spacing: 1px; opacity: 0.6;
            margin-bottom: 10px; font-size: 0.75rem; font-weight: bold;
            display: flex; align-items: center; gap: 5px;
        }

        select, .custom-file-upload, textarea, input[type="number"], input[type="text"] {
            width: 100%; padding: 8px; border-radius: 6px;
            border: 1px solid rgba(128,128,128,0.5); 
            background: var(--input-bg); 
            color: inherit; font-weight: bold; cursor: pointer; outline: none;
            font-size: 0.85rem; box-sizing: border-box;
            font-family: inherit;
        }
        textarea { resize: vertical; min-height: 80px; font-weight: normal; font-size: 0.8rem; line-height: 1.4; white-space: pre; }
        select option { background: #222; color: white; }

        .toggle-row { display: flex; justify-content: space-between; align-items: center; width: 100%; cursor: pointer; padding: 5px 0; }
        .toggle-row:hover label { opacity: 1; }
        .toggle-row label { cursor: pointer; flex-grow: 1; opacity: 0.8; font-size: 0.9rem; }
        input[type="checkbox"] { width: 18px; height: 18px; cursor: pointer; accent-color: var(--accent); }

        .slider-group { display: flex; align-items: center; justify-content: space-between; gap: 10px; margin-bottom: 5px; }
        .slider-group label { font-size: 0.8rem; opacity: 0.8; width: 60px; flex-shrink: 0; }
        input[type="range"] { 
            flex-grow: 1; cursor: pointer; accent-color: var(--accent); 
            height: 6px; 
            background: rgba(128, 128, 128, 0.4); 
            border-radius: 3px; 
            appearance: none;
            -webkit-appearance: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 16px; width: 16px;
            background: var(--panel-text);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
        }

        input[type="number"].slider-val {
            width: 45px;
            flex-shrink: 0;
            padding: 2px 5px;
            margin-left: 5px;
            text-align: center;
            background: var(--input-bg); 
            font-size: 0.75rem;
            -moz-appearance: textfield;
        }
        input[type="number"].slider-val::-webkit-outer-spin-button,
        input[type="number"].slider-val::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        .pattern-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 6px; margin-bottom: 10px; }
        .pattern-btn {
            height: 40px; border-radius: 6px; border: 1px solid rgba(255,255,255,0.2);
            cursor: pointer; transition: transform 0.1s, border-color 0.2s;
            background-color: #222 !important; background-size: cover; background-position: center !important; 
        }
        .pattern-btn:hover { transform: scale(1.02); border-color: var(--accent); }
        
        .pat-none { background: #222; position: relative; }
        .pat-none::after { content: 'üö´'; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); }
        .pat-dots { background-image: url('data:image/svg+xml;utf8,<svg width="20" height="20" xmlns="http://www.w3.org/2000/svg"><circle cx="10" cy="10" r="4" fill="white" opacity="0.8"/></svg>'); }
        .pat-stripes { background-image: url('data:image/svg+xml;utf8,<svg width="20" height="20" xmlns="http://www.w3.org/2000/svg"><path d="M0 20 L20 0 L10 0 L0 10 Z" fill="white" opacity="0.6"/><path d="M10 20 L20 10 L20 20 Z" fill="white" opacity="0.6"/></svg>'); }
        .pat-grid { background-image: url('data:image/svg+xml;utf8,<svg width="20" height="20" xmlns="http://www.w3.org/2000/svg"><path d="M10 0 L10 20 M0 10 L20 10" stroke="white" stroke-width="2" opacity="0.8"/></svg>'); }
        .pat-check { background-image: url('data:image/svg+xml;utf8,<svg width="20" height="20" xmlns="http://www.w3.org/2000/svg"><rect x="0" y="0" width="10" height="10" fill="white" opacity="0.5"/><rect x="10" y="10" width="10" height="10" fill="white" opacity="0.5"/></svg>'); }
        .pat-zig { background-image: url('data:image/svg+xml;utf8,<svg width="20" height="20" xmlns="http://www.w3.org/2000/svg"><path d="M0 0 L10 10 L20 0 L20 5 L10 15 L0 5 Z" fill="white" opacity="0.6"/></svg>'); }

        /* Layout Buttons */
        .layout-btn {
            height: 40px; border-radius: 6px; border: 1px solid rgba(255,255,255,0.2);
            cursor: pointer; transition: transform 0.1s, border-color 0.2s;
            background: rgba(0,0,0,0.3); display: flex; flex-direction: column; justify-content: center; align-items: center; gap: 2px;
        }
        .layout-btn:hover { transform: scale(1.02); border-color: var(--accent); }
        .l-box { background: rgba(255,255,255,0.8); width: 15px; height: 6px; border-radius: 1px; }
        .l-line { background: rgba(255,255,255,0.4); width: 20px; height: 2px; border-radius: 1px; }

        input[type="file"] { display: none; }
        .file-label {
            display: block; width: 100%; text-align: center; padding: 8px; 
            background: var(--input-bg); border-radius: 6px; font-size: 0.8rem; 
            cursor: pointer; transition: background 0.2s; box-sizing: border-box;
            border: 1px solid rgba(128,128,128,0.2);
        }
        .file-label:hover { background: rgba(128,128,128,0.2); }
        .btn-delete { background: #e74c3c; color: #fff; margin-top:5px; border:none; padding:8px; border-radius:6px; cursor:pointer; width:100%; font-weight:bold; }
        .btn-delete:hover { background: #c0392b; }
        .btn-add-text { background: #9b59b6; color: #fff; border:none; padding:8px; border-radius:6px; cursor:pointer; width:100%; font-weight:bold; }
        .btn-add-text:hover { background: #8e44ad; }

        .audio-actions { display: flex; gap: 5px; margin-top: 5px; }
        .audio-btn { flex: 1; padding: 6px; font-size: 0.75rem; border-radius: 4px; border:none; cursor: pointer; font-weight: bold; opacity: 0.8; transition: opacity 0.2s;}
        .audio-btn:hover { opacity: 1; }
        .btn-test { background: #2ecc71; color: #fff; }
        .btn-clear { background: #e74c3c; color: #fff; }

        .audio-trimmer {
            background: var(--inner-panel-bg); 
            padding: 10px; border-radius: 6px;
            display: none; flex-direction: column; gap: 8px; margin-top: 5px;
        }
        .trim-info { display: flex; justify-content: space-between; font-size: 0.7rem; opacity: 0.7; }

        .controls {
            position: fixed; bottom: 20px; background: var(--panel-bg); backdrop-filter: blur(10px);
            padding: 10px 20px; border-radius: 50px; display: flex; gap: 10px; align-items: center;
            flex-wrap: wrap; justify-content: center; box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            transition: opacity 0.3s ease, transform 0.3s ease; z-index: 100;
            resize: both; overflow: hidden; min-width: 320px; max-width: 90vw;
        }

        body.fullscreen-mode .controls { opacity: 0; pointer-events: none; transform: translateY(30px); }
        body.fullscreen-mode.show-controls .controls { opacity: 1; pointer-events: auto; transform: translateY(0); }
        body.fullscreen-mode:not(.show-controls) .settings-panel { opacity: 0 !important; pointer-events: none !important; }
        body.cuber-running .controls, body.cuber-running .settings-panel { opacity: 0 !important; pointer-events: none !important; }

        button.main-btn {
            padding: 8px 16px; border: none; border-radius: 20px; font-weight: bold; cursor: pointer;
            background-color: var(--panel-text); color: var(--panel-bg); transition: transform 0.1s;
            font-size: 0.9rem; min-width: 40px;
        }
        button.main-btn:active { transform: scale(0.95); }
        input[type="color"] { border: none; width: 35px; height: 35px; cursor: pointer; background: none; padding: 0; }

        .custom-alert-box {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background-color: var(--panel-bg); color: var(--panel-text); padding: 20px;
            border-radius: 15px; box-shadow: 0 10px 40px rgba(0,0,0,0.6);
            border: 1px solid rgba(128, 128, 128, 0.4); backdrop-filter: blur(20px);
            z-index: 2000; min-width: 250px; text-align: center; opacity: 0; pointer-events: none;
            transition: opacity 0.3s; display: flex; flex-direction: column; gap: 15px;
        }
        .custom-alert-box.active { opacity: 1; pointer-events: auto; }
        .alert-ok-btn {
            background: rgba(255,255,255,0.1); color: inherit; border: 1px solid rgba(128,128,128,0.5);
            padding: 8px 20px; border-radius: 10px; cursor: pointer; font-weight: bold; align-self: center;
        }

        /* --- LAYERS PANEL STYLES --- */
        #layersList {
            display: flex; flex-direction: column; gap: 5px;
            max-height: 200px; overflow-y: auto; padding: 5px;
            background: rgba(0,0,0,0.2); border-radius: 6px;
        }
        .layer-item {
            display: flex; align-items: center; gap: 10px;
            padding: 5px 10px; background: rgba(255,255,255,0.05);
            border-radius: 4px; cursor: pointer; transition: background 0.2s;
            border: 1px solid transparent;
        }
        .layer-item:hover { background: rgba(255,255,255,0.1); }
        .layer-item.active-layer { border-color: var(--accent); background: rgba(255,255,255,0.15); }
        .layer-item.system-layer { background: rgba(52, 152, 219, 0.2); }
        
        .layer-thumb { width: 30px; height: 30px; object-fit: cover; border-radius: 4px; background: #000; }
        .layer-icon-text { width: 30px; height: 30px; display: flex; align-items: center; justify-content: center; background: #555; border-radius: 4px; font-size: 1.2rem; }
        .layer-name { flex-grow: 1; font-size: 0.8rem; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; text-align: left; }
        
        .layer-controls { display: flex; gap: 2px; }
        .layer-btn { 
            background: none; border: 1px solid rgba(255,255,255,0.2); color: inherit; 
            width: 24px; height: 24px; border-radius: 4px; cursor: pointer;
            display: flex; align-items: center; justify-content: center; font-size: 0.7rem;
        }
        .layer-btn:hover { background: rgba(255,255,255,0.2); }
        .layer-btn.btn-del-layer:hover { background: #e74c3c; border-color: #e74c3c; }
        
        .layer-btn.locked { color: #e74c3c; }

        .no-layers { font-size: 0.8rem; opacity: 0.5; padding: 10px; text-align: center; }
        
        #activeWidgetSettings { display: none; margin-top: 10px; border-top: 1px solid rgba(128,128,128,0.2); padding-top: 10px; }
    </style>
</head>
<body>

    <div id="widgetLayer"></div>

    <div id="guide-v" class="guide-line guide-v"></div>
    <div id="guide-h" class="guide-line guide-h"></div>

    <div class="container" id="mainContainer">
        <div id="pomoStatus" class="pomo-status">üí™ FOCUS MODE</div>
        
        <div id="scrambleDisplay" class="scramble-display"></div>
        <h1 id="mainTitle" contenteditable="true" spellcheck="false">Made by CircleSide with Gemini!</h1>
        <div class="timer-display" id="timer" contenteditable="true" spellcheck="false">05:00</div>
        
        <div id="statsDisplay" class="stats-container"></div>

        <div id="worldClockContainer" class="world-clock-container">
            <div class="local-time-wrapper">
                <div id="localTime" class="local-time">12:00:00</div>
                <div id="localDate" class="local-date">Mon, Jan 1</div>
            </div>
            <div id="citiesGrid" class="cities-grid">
                </div>
        </div>
    </div>

    <div id="customAlert" class="custom-alert-box">
        <div id="alertMsg" style="font-size:1rem; line-height:1.4;"></div>
        <button class="alert-ok-btn" onclick="closeAlert()">OK</button>
    </div>

    <div id="settingsPanel" class="settings-panel hidden">
        <div class="panel-header" id="panelHeader">
            <span>‚öôÔ∏è Settings</span>
            <button class="close-btn" onclick="toggleSettings()">‚úñ</button>
        </div>
        
        <div class="panel-content">
            <div class="settings-section">
                <div class="section-title">‚â° Layers</div>
                <div id="layersList">
                    <div class="no-layers">No widgets added</div>
                </div>
                
                <div id="activeWidgetSettings">
                    <div class="section-title">Widget Settings</div>
                    <div id="textWidgetControls">
                        <input type="text" id="widgetTextInput" placeholder="Edit Text" oninput="updateActiveWidgetText()" style="margin-bottom:5px;">
                        <div class="slider-group">
                            <label>Size</label>
                            <input type="range" id="widgetSizeInput" min="10" max="300" oninput="updateActiveWidgetSize()">
                        </div>
                        <div class="slider-group">
                            <label>Color</label>
                            <input type="color" id="widgetColorInput" oninput="updateActiveWidgetColor()" style="width:100%; height:30px;">
                        </div>
                    </div>
                </div>
            </div>

            <div class="settings-section">
                <div class="section-title">üé® Appearance</div>
                <div style="margin-bottom:10px;">
                    <select id="fontSelect" onchange="changeFont()">
                        <option value="'Inter', sans-serif">Modern (Inter)</option>
                        <option value="'Roboto', sans-serif">Standard (Roboto)</option>
                        <option value="'Orbitron', sans-serif">Digital (Orbitron)</option>
                        <option value="'JetBrains Mono', monospace">Coding (JetBrains)</option>
                        <option value="'Press Start 2P', cursive">Retro (Pixel)</option>
                        <option value="'Bangers', cursive">Impact (Bangers)</option>
                        <option value="'Lobster', cursive">Fun (Lobster)</option>
                        <option value="'Oswald', sans-serif">Bold (Oswald)</option>
                        <option value="'Playfair Display', serif">Elegant (Playfair)</option>
                        <option value="'Pacifico', cursive">Handwriting (Pacifico)</option>
                        <option value="'Caveat', cursive">Marker (Caveat)</option>
                    </select>
                </div>
                <div class="toggle-row" onclick="document.getElementById('titleToggle').click()">
                    <label>Show Message</label> <input type="checkbox" id="titleToggle" checked onchange="toggleTitleVisibility()" onclick="event.stopPropagation()">
                </div>
                <div class="toggle-row" onclick="document.getElementById('msToggle').click()">
                    <label>Show MS</label> <input type="checkbox" id="msToggle" onchange="toggleMsVisibility()" onclick="event.stopPropagation()">
                </div>
            </div>

            <div class="settings-section">
                <div class="section-title">üìê Layout</div>
                <div class="pattern-grid" style="grid-template-columns: repeat(4, 1fr);">
                    <div class="layout-btn" onclick="changeLayout('standard')" title="Standard (Text Top)">
                        <div class="l-line" style="width:15px"></div>
                        <div class="l-box"></div>
                    </div>
                    <div class="layout-btn" onclick="changeLayout('inverted')" title="Inverted (Timer Top)">
                        <div class="l-box"></div>
                        <div class="l-line" style="width:15px"></div>
                    </div>
                    <div class="layout-btn" onclick="changeLayout('split')" title="Split (Text Left)">
                        <div style="display:flex; gap:2px; align-items:center;">
                            <div class="l-line" style="width:5px; height:10px;"></div>
                            <div class="l-box" style="width:10px; height:10px;"></div>
                        </div>
                    </div>
                    <div class="layout-btn" onclick="changeLayout('split-rev')" title="Split (Timer Left)">
                        <div style="display:flex; gap:2px; align-items:center;">
                            <div class="l-box" style="width:10px; height:10px;"></div>
                            <div class="l-line" style="width:5px; height:10px;"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="settings-section">
                <div class="section-title">üñºÔ∏è Background & Widgets</div>
                
                <div style="display:flex; flex-direction:column; gap:5px; margin-top:5px;">
                    <div style="display:flex; gap:5px;">
                         <button class="btn-add-text" onclick="addTextWidget()">‚ûï Add Text Widget</button>
                    </div>
                    <div style="display:flex; gap:5px;">
                        <label class="file-label" for="widgetImageFile">‚ûï Add Image Widget</label>
                        <input type="file" id="widgetImageFile" accept="image/*">
                    </div>
                </div>
                <div class="toggle-row" onclick="document.getElementById('snapToggle').click()">
                    <label>üß≤ Snap to Grid</label> <input type="checkbox" id="snapToggle" checked onclick="event.stopPropagation()">
                </div>
                <button class="btn-delete" onclick="clearAllWidgets()">üóëÔ∏è Clear All Widgets</button>

                <div class="section-title" style="margin-top:10px;">Background Pattern</div>
                <div class="pattern-grid">
                    <div class="pattern-btn pat-none" onclick="selectPattern('none')" title="None"></div>
                    <div class="pattern-btn pat-dots" onclick="selectPattern('dots')" title="Dots"></div>
                    <div class="pattern-btn pat-stripes" onclick="selectPattern('stripes')" title="Stripes"></div>
                    <div class="pattern-btn pat-grid" onclick="selectPattern('grid')" title="Grid"></div>
                    <div class="pattern-btn pat-check" onclick="selectPattern('check')" title="Checkers"></div>
                    <div class="pattern-btn pat-zig" onclick="selectPattern('zig')" title="ZigZag"></div>
                </div>
                
                <div class="slider-group">
                    <label>Color</label>
                    <input type="color" id="patColor" value="#ffffff" oninput="updatePatternStyle()" style="height:35px; width:60px;">
                </div>
                <div class="slider-group">
                    <label>Opacity</label>
                    <input type="range" id="patOpacity" min="5" max="100" value="20" oninput="document.getElementById('patOpacityNum').value = this.value; updatePatternStyle()">
                    <input type="number" id="patOpacityNum" class="slider-val" value="20" min="5" max="100" oninput="document.getElementById('patOpacity').value = this.value; updatePatternStyle()">
                </div>

                <div style="display:flex; gap:5px; margin-top:5px;">
                      <label class="file-label" for="bgImageFile">Set BG Image</label>
                      <input type="file" id="bgImageFile" accept="image/*">
                </div>
                
                <div class="section-title" style="margin-top:10px;">Position</div>
                <div class="slider-group">
                    <label>Zoom</label>
                    <input type="range" id="bgZoom" min="10" max="200" value="30" oninput="document.getElementById('bgZoomNum').value = this.value; updateBgParams()">
                    <input type="number" id="bgZoomNum" class="slider-val" value="30" min="10" max="200" oninput="document.getElementById('bgZoom').value = this.value; updateBgParams()">
                </div>
                <div class="slider-group">
                    <label>Pan X</label>
                    <input type="range" id="bgPanX" min="0" max="100" value="50" oninput="document.getElementById('bgPanXNum').value = this.value; updateBgParams()">
                    <input type="number" id="bgPanXNum" class="slider-val" value="50" min="0" max="100" oninput="document.getElementById('bgPanX').value = this.value; updateBgParams()">
                </div>
                <div class="slider-group">
                    <label>Pan Y</label>
                    <input type="range" id="bgPanY" min="0" max="100" value="50" oninput="document.getElementById('bgPanYNum').value = this.value; updateBgParams()">
                    <input type="number" id="bgPanYNum" class="slider-val" value="50" min="0" max="100" oninput="document.getElementById('bgPanY').value = this.value; updateBgParams()">
                </div>
                <div class="toggle-row" onclick="document.getElementById('blendToggle').click()" style="margin-top:5px;">
                    <label>Blend Mode</label> <input type="checkbox" id="blendToggle" checked onchange="updatePatternStyle()" onclick="event.stopPropagation()">
                </div>
            </div>

            <div class="settings-section">
                <div class="section-title">üïπÔ∏è Modes</div>
                
                <div class="toggle-row" onclick="document.getElementById('cuberToggle').click()">
                    <label>üßä Cuber Mode</label> <input type="checkbox" id="cuberToggle" onchange="toggleCuberMode()" onclick="event.stopPropagation()">
                </div>
                
                <div class="toggle-row" onclick="document.getElementById('pomoToggle').click()" style="border-top:1px solid rgba(128,128,128,0.2); margin-top:5px; padding-top:5px;">
                    <label>üçÖ Pomodoro</label> <input type="checkbox" id="pomoToggle" onchange="togglePomoMode()" onclick="event.stopPropagation()">
                </div>

                <div id="pomoControls" style="display:none; margin-top:10px; background:var(--inner-panel-bg); padding:10px; border-radius:6px;">
                    <div class="slider-group">
                        <label style="width:70px">Work (m)</label>
                        <input type="number" id="pomoWork" value="25" min="1" max="120" onchange="updatePomoSettings()">
                    </div>
                    <div class="slider-group">
                        <label style="width:70px">Short (m)</label>
                        <input type="number" id="pomoShort" value="5" min="1" max="60" onchange="updatePomoSettings()">
                    </div>
                    <div class="slider-group">
                        <label style="width:70px">Long (m)</label>
                        <input type="number" id="pomoLong" value="15" min="1" max="120" onchange="updatePomoSettings()">
                    </div>
                </div>

                <div class="toggle-row" onclick="document.getElementById('clockToggle').click()" style="border-top:1px solid rgba(128,128,128,0.2); margin-top:5px; padding-top:5px;">
                    <label>üåé World Clock</label> <input type="checkbox" id="clockToggle" onchange="toggleClockMode()" onclick="event.stopPropagation()">
                </div>
                
                <div id="clockControls" style="display:none; margin-top:10px; padding:10px; background:var(--inner-panel-bg); border-radius:6px;">
                    <div class="section-title">Show Cities:</div>
                    <div style="display:grid; grid-template-columns: 1fr 1fr; gap:5px;">
                        <label><input type="checkbox" class="city-check" value="Manila" checked onchange="updateCitySelection()"> Manila</label>
                        <label><input type="checkbox" class="city-check" value="Tokyo" checked onchange="updateCitySelection()"> Tokyo</label>
                        <label><input type="checkbox" class="city-check" value="London" checked onchange="updateCitySelection()"> London</label>
                        <label><input type="checkbox" class="city-check" value="New York" checked onchange="updateCitySelection()"> NYC</label>
                        <label><input type="checkbox" class="city-check" value="Paris" onchange="updateCitySelection()"> Paris</label>
                        <label><input type="checkbox" class="city-check" value="Sydney" onchange="updateCitySelection()"> Sydney</label>
                        <label><input type="checkbox" class="city-check" value="Dubai" onchange="updateCitySelection()"> Dubai</label>
                        <label><input type="checkbox" class="city-check" value="Los Angeles" onchange="updateCitySelection()"> LA</label>
                    </div>
                </div>
                
                <div class="toggle-row" onclick="document.getElementById('lyricToggle').click()" style="border-top:1px solid rgba(128,128,128,0.2); margin-top:5px; padding-top:5px;">
                    <label>üéµ Lyric Sync</label> <input type="checkbox" id="lyricToggle" onchange="toggleLyricMode()" onclick="event.stopPropagation()">
                </div>
                
                <div id="lyricControls" style="display:none; margin-top:10px;">
                    <div style="margin-bottom:10px; display:flex; gap:5px; align-items:center;">
                        <div style="flex-grow:1;">
                             <label class="file-label" for="lyricAudioFile">üéµ Upload Song</label>
                             <input type="file" id="lyricAudioFile" accept="audio/*">
                        </div>
                        <button class="audio-btn btn-clear" onclick="clearLyricAudio()" style="width:auto; padding:0 10px;">‚úñ</button>
                    </div>
                    <div id="lyricAudioStatus" style="font-size:0.75rem; text-align:center; opacity:0.7; margin-top:2px;">No file chosen</div>

                    <div id="lyricAudioSettings" style="display:none; background:var(--inner-panel-bg); padding:8px; border-radius:6px; margin-bottom:10px; margin-top:10px;">
                        <div class="slider-group">
                            <label>Vol</label>
                            <input type="range" id="lyricVol" min="0" max="100" value="80" oninput="document.getElementById('lyricVolNum').value=this.value; updateLyricVolume(this.value)">
                            <input type="number" id="lyricVolNum" class="slider-val" value="80" min="0" max="100" oninput="document.getElementById('lyricVol').value=this.value; updateLyricVolume(this.value)">
                        </div>
                        <div class="audio-trimmer" style="display:flex; margin-top:0; background:none; padding:0;">
                            <div class="trim-info"><span>Start</span><span id="lyricTrimStartVal">0.0s</span></div>
                            <input type="range" id="lyricTrimStart" min="0" max="10" step="0.1" value="0" oninput="updateLyricTrim()">
                            <div class="trim-info"><span>Length</span><span id="lyricTrimDurVal">--</span></div>
                            <input type="range" id="lyricTrimDuration" min="1" max="10" step="1" value="300" oninput="updateLyricTrim()">
                        </div>
                    </div>

                    <textarea id="lyricInput" placeholder="Paste LRC format: [mm:ss.xx] Lyric"></textarea>
                    
                    <div class="slider-group" id="speedControlGroup" style="margin-top:5px;">
                        <label style="width:auto">Speed (s)</label>
                        <input type="range" id="lyricSpeed" min="1" max="10" value="3" oninput="document.getElementById('lyricSpeedNum').value = this.value">
                        <input type="number" id="lyricSpeedNum" class="slider-val" value="3" min="1" max="10" oninput="document.getElementById('lyricSpeed').value = this.value">
                    </div>
                    <div id="lrcStatus" style="font-size:0.75rem; opacity:0.7; margin-top:5px; display:none; color: #2ecc71;">
                        ‚úì LRC Timestamps Detected
                    </div>
                </div>
            </div>

            <div class="settings-section">
                <div class="section-title">üîä Audio</div>
                <div class="slider-group">
                    <label>Click</label>
                    <input type="range" id="volClickRange" min="0" max="100" value="30" oninput="document.getElementById('volClickNum').value=this.value; volClick = this.value/100; playClick()">
                    <input type="number" id="volClickNum" class="slider-val" value="30" min="0" max="100" oninput="document.getElementById('volClickRange').value=this.value; volClick = this.value/100; playClick()">
                </div>
                <div class="slider-group">
                    <label>Tick</label>
                    <input type="range" id="volTickRange" min="0" max="100" value="10" oninput="document.getElementById('volTickNum').value=this.value; volTick = this.value/100; playTick()">
                    <input type="number" id="volTickNum" class="slider-val" value="10" min="0" max="100" oninput="document.getElementById('volTickRange').value=this.value; volTick = this.value/100; playTick()">
                </div>
                <div class="slider-group">
                    <label>Alarm</label>
                    <input type="range" id="volAlarmRange" min="0" max="100" value="50" oninput="document.getElementById('volAlarmNum').value=this.value; volAlarm = this.value/100;">
                    <input type="number" id="volAlarmNum" class="slider-val" value="50" min="0" max="100" oninput="document.getElementById('volAlarmRange').value=this.value; volAlarm = this.value/100;">
                </div>

                <div style="margin-top:10px;">
                    <label class="file-label" for="audioFile">Upload Custom Alarm</label>
                    <input type="file" id="audioFile" accept="audio/*">
                    
                    <div class="audio-actions">
                        <button class="audio-btn btn-test" onclick="playCustomPreview()">‚ñ∂ Test</button>
                        <button class="audio-btn btn-clear" onclick="clearCustomAudio()">‚úñ Remove</button>
                    </div>

                    <div class="audio-trimmer" id="audioTrimmer">
                        <div class="trim-info"><span>Start</span><span id="trimStartVal">0.0s</span></div>
                        <input type="range" id="trimStart" min="0" max="10" step="0.1" value="0">
                        <div class="trim-info"><span>Length</span><span id="trimDurVal">1.0s</span></div>
                        <input type="range" id="trimDuration" min="0.1" max="10" step="0.1" value="5">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="controls">
        <input type="color" id="colorPicker" value="#3498db" title="Change Theme">
        <button class="main-btn" id="toggleBtn" onmousedown="playClick()" onclick="toggleTimer()">Start</button>
        <button class="main-btn" onmousedown="playClick()" onclick="resetTimer()">Reset</button>
        <button class="main-btn" onmousedown="playClick()" onclick="toggleFullScreen()" title="Fullscreen">‚õ∂</button>
        <button class="main-btn" onmousedown="playClick()" onclick="toggleSettings()" title="Settings">‚öôÔ∏è</button>
    </div>

    <script>
        let timeLeft = 300000, originalTime = 300000;
        let timerInterval, isRunning = false, isEditing = false;
        let isCuberMode = false, holdTimeout, isArmed = false;
        let timerEndTime = 0, timerStartTime = 0, lastSecond = 0;
        let currentBgMode = 'none', currentPatternType = 'none';
        let volClick = 0.3, volTick = 0.1, volAlarm = 0.5, customAlarmBuffer = null;
        let solveHistory = []; 
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        const audioCtx = new AudioContext();

        // LYRIC VARS
        let isLyricMode = false;
        let lyricLines = []; 
        let isLrcFormat = false;
        let lyricIndex = 0;
        let lyricInterval; 
        let lyricAudio = null; 
        let lyricStartTime = 0;
        let lyricDuration = 300; 
        
        // POMODORO VARS
        let isPomoMode = false;
        let pomoState = 'work'; 
        let pomoWorkTime = 25;
        let pomoShortTime = 5;
        let pomoLongTime = 15;

        // WORLD CLOCK VARS
        let isClockMode = false;
        let clockInterval;
        let selectedCities = ["Manila", "Tokyo", "London", "New York"];
        const cityTimeZones = {
            "Manila": "Asia/Manila",
            "Tokyo": "Asia/Tokyo",
            "London": "Europe/London",
            "New York": "America/New_York",
            "Paris": "Europe/Paris",
            "Sydney": "Australia/Sydney",
            "Dubai": "Asia/Dubai",
            "Los Angeles": "America/Los_Angeles"
        };

        // ALARM VARS
        let alarmTimeout, alarmInterval, activeAlarmSource;
        let audioDuration = 0;

        // WIDGET VARS
        let widgets = []; // Array to store widget objects {id, el, src, type, etc}
        let activeWidgetId = null;
        let isDraggingWidget = false, isResizingWidget = false, isRotatingWidget = false;
        let startX, startY, startWidth, startHeight, startRotation, startCenterX, startCenterY;

        // Elements
        const mainContainer = document.getElementById('mainContainer');
        const timerDisplay = document.getElementById('timer');
        const mainTitle = document.getElementById('mainTitle');
        const scrambleDisplay = document.getElementById('scrambleDisplay');
        const statsDisplay = document.getElementById('statsDisplay'); 
        const settingsPanel = document.getElementById('settingsPanel');
        const panelHeader = document.getElementById('panelHeader');
        const customAlert = document.getElementById('customAlert');
        const alertMsg = document.getElementById('alertMsg');
        const pomoStatus = document.getElementById('pomoStatus');
        const widgetLayer = document.getElementById('widgetLayer');
        const guideV = document.getElementById('guide-v');
        const guideH = document.getElementById('guide-h');
        const snapToggle = document.getElementById('snapToggle');
        const layersList = document.getElementById('layersList');
        
        const worldClockContainer = document.getElementById('worldClockContainer');
        const localTimeDisplay = document.getElementById('localTime');
        const localDateDisplay = document.getElementById('localDate');
        const citiesGrid = document.getElementById('citiesGrid');

        // Inputs
        const fontSelect = document.getElementById('fontSelect');
        const sliderZoom = document.getElementById('bgZoom');
        const sliderPanX = document.getElementById('bgPanX');
        const sliderPanY = document.getElementById('bgPanY');
        const patColorInput = document.getElementById('patColor');
        const patOpacityInput = document.getElementById('patOpacity');
        const blendToggle = document.getElementById('blendToggle');
        
        const cuberToggle = document.getElementById('cuberToggle');
        const pomoToggle = document.getElementById('pomoToggle');
        const clockToggle = document.getElementById('clockToggle');
        
        const colorPicker = document.getElementById('colorPicker');
        
        // Pomo Inputs
        const pomoControls = document.getElementById('pomoControls');
        const pomoWorkInput = document.getElementById('pomoWork');
        const pomoShortInput = document.getElementById('pomoShort');
        const pomoLongInput = document.getElementById('pomoLong');
        
        // Clock Inputs
        const clockControls = document.getElementById('clockControls');

        // Lyric Inputs
        const lyricControls = document.getElementById('lyricControls');
        const lyricInput = document.getElementById('lyricInput');
        const lyricSpeedInput = document.getElementById('lyricSpeed');
        const speedControlGroup = document.getElementById('speedControlGroup');
        const lrcStatus = document.getElementById('lrcStatus');
        const lyricAudioInput = document.getElementById('lyricAudioFile');
        const lyricAudioStatus = document.getElementById('lyricAudioStatus');
        const lyricAudioSettings = document.getElementById('lyricAudioSettings');
        const lyricTrimStartInput = document.getElementById('lyricTrimStart');
        const lyricTrimDurInput = document.getElementById('lyricTrimDuration');
        const lyricTrimStartVal = document.getElementById('lyricTrimStartVal');
        const lyricTrimDurVal = document.getElementById('lyricTrimDurVal');

        // Trim Inputs
        const trimmerDiv = document.getElementById('audioTrimmer');
        const trimStartInput = document.getElementById('trimStart');
        const trimDurInput = document.getElementById('trimDuration');
        const trimStartVal = document.getElementById('trimStartVal');
        const trimDurVal = document.getElementById('trimDurVal');

        // Widget Settings Inputs
        const activeWidgetSettings = document.getElementById('activeWidgetSettings');
        const widgetTextInput = document.getElementById('widgetTextInput');
        const widgetSizeInput = document.getElementById('widgetSizeInput');
        const widgetColorInput = document.getElementById('widgetColorInput');

        function init() {
            updateColors(colorPicker.value);
            // Add System Layer
            widgets.push({ id: 'system-ui', type: 'system', name: '‚è±Ô∏è Timer & Title', fixed: true, locked: false });
            
            if(cuberToggle.checked) { isCuberMode = true; timerDisplay.setAttribute('contenteditable', 'false'); scrambleDisplay.style.display = 'block'; generateScramble(); }
            updateLayout(); updateDisplay();
            renderLayerList();
            updateLayerZIndices();
        }

        /* --- WIDGET SYSTEM --- */
        document.getElementById('widgetImageFile').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = function(ev) {
                createWidget('image', ev.target.result, file.name);
                showAlert("Image Added!<br>Check Layers Tab.");
                playClick();
            };
            reader.readAsDataURL(file);
            e.target.value = ''; 
        });

        function addTextWidget() {
            createWidget('text', 'New Text', 'Text Widget');
            showAlert("Text Added!");
            playClick();
        }

        function createWidget(type, content, name) {
            const id = Date.now().toString(); // Simple Unique ID
            const widget = document.createElement('div');
            widget.className = 'widget';
            widget.id = 'w-' + id;
            widget.style.left = '50%';
            widget.style.top = '50%';
            widget.dataset.rotation = '0';
            
            const offsetX = (Math.random() - 0.5) * 100;
            const offsetY = (Math.random() - 0.5) * 100;
            widget.style.transform = `translate(calc(-50% + ${offsetX}px), calc(-50% + ${offsetY}px)) rotate(0deg)`;

            let innerHTML = '';
            // Default properties
            let props = { type: type, name: name || 'Widget', locked: false };

            if (type === 'image') {
                widget.style.width = '200px';
                innerHTML = `<img src="${content}" draggable="false">`;
                props.src = content;
            } else if (type === 'text') {
                widget.style.width = 'max-content'; // CHANGED: Was 'auto'. Prevents wrapping at screen edge.
                widget.style.minWidth = '50px';
                innerHTML = `<div class="widget-text-content" style="color: #ffffff; font-size: 50px;">${content}</div>`;
                props.text = content;
                props.color = '#ffffff';
                props.fontSize = 50;
            }

            innerHTML += `
                <div class="widget-controls">
                    <div class="w-handle w-delete">‚úï</div>
                    <div class="w-handle w-rotate"></div>
                    <div class="w-handle w-resize"></div>
                </div>
            `;
            widget.innerHTML = innerHTML;
            
            // Add Double Click to Edit
            widget.ondblclick = (e) => {
                e.stopPropagation(); 
                if(type === 'text') enterTextEditMode(id);
            };
            
            widgetLayer.appendChild(widget);
            
            // Add to data array (Newest is Top = End of Array)
            widgets.push({ id: id, el: widget, ...props });
            
            updateLayerZIndices();
            renderLayerList();
            activateWidgetId(id);
        }
        
        function enterTextEditMode(id) {
            const wObj = widgets.find(w => w.id === id);
            if (!wObj || wObj.type !== 'text' || wObj.locked) return;

            const textEl = wObj.el.querySelector('.widget-text-content');
            if (!textEl) return;

            textEl.contentEditable = "true";
            textEl.focus();
            
            // Select all text
            const range = document.createRange();
            range.selectNodeContents(textEl);
            const sel = window.getSelection();
            sel.removeAllRanges();
            sel.addRange(range);

            // Save handlers to remove later if needed, or just overwrite properties
            textEl.onblur = function() {
                this.contentEditable = "false";
                wObj.text = this.innerText; // Sync data
                if(activeWidgetId === id) widgetTextInput.value = wObj.text; // Sync settings panel
                window.getSelection().removeAllRanges();
            };
            
            textEl.onkeydown = function(e) {
                e.stopPropagation(); // Prevent global hotkeys while typing
            };
            
            textEl.oninput = function() {
                wObj.text = this.innerText; // Live sync
            };
        }

        function updateLayerZIndices() {
            // Apply z-index based on array order (0 is bottom, length-1 is top)
            // Base Z is 10
            widgets.forEach((w, index) => {
                if (w.type === 'system') {
                    mainContainer.style.zIndex = 10 + index;
                } else {
                    w.el.style.zIndex = 10 + index; 
                }
            });
        }

        function renderLayerList() {
            layersList.innerHTML = '';
            if (widgets.length === 0) {
                layersList.innerHTML = '<div class="no-layers">No widgets added</div>';
                activeWidgetSettings.style.display = 'none';
                return;
            }

            // Render list in REVERSE order (Top layer first in UI)
            const reversed = [...widgets].reverse();
            
            reversed.forEach((w, revIndex) => {
                // Real index in original array
                const realIndex = widgets.length - 1 - revIndex; 
                
                const item = document.createElement('div');
                item.className = 'layer-item';
                if(w.id === activeWidgetId) item.classList.add('active-layer');
                if(w.type === 'system') item.classList.add('system-layer');
                
                let thumbHTML = '';
                if(w.type === 'image') {
                    thumbHTML = `<img src="${w.src}" class="layer-thumb">`;
                } else if (w.type === 'text') {
                    thumbHTML = `<div class="layer-icon-text">T</div>`;
                } else if (w.type === 'system') {
                    thumbHTML = `<div class="layer-icon-text">‚è±Ô∏è</div>`;
                }

                const lockIcon = w.locked ? 'üîí' : 'üîì';
                const lockClass = w.locked ? 'locked' : '';
                
                let controlsHTML = `
                    <button class="layer-btn ${lockClass}" onclick="toggleWidgetLock('${w.id}')" title="Lock/Unlock">${lockIcon}</button>
                `;

                if(!w.locked) {
                    controlsHTML += `
                        <button class="layer-btn" onclick="moveLayer(${realIndex}, 1)" title="Bring Forward">‚Üë</button>
                        <button class="layer-btn" onclick="moveLayer(${realIndex}, -1)" title="Send Backward">‚Üì</button>
                    `;
                    
                    if(w.type !== 'system') {
                        controlsHTML += `<button class="layer-btn btn-del-layer" onclick="deleteWidgetById('${w.id}')" title="Delete">‚úï</button>`;
                    }
                }

                item.innerHTML = `
                    ${thumbHTML}
                    <div class="layer-name">${w.name}</div>
                    <div class="layer-controls">
                        ${controlsHTML}
                    </div>
                `;
                
                // Click to select
                item.addEventListener('click', (e) => {
                    if(e.target.closest('.layer-btn')) return; // Ignore buttons
                    if(w.type !== 'system' && !w.locked) activateWidgetId(w.id);
                });

                layersList.appendChild(item);
            });
        }

        function toggleWidgetLock(id) {
            const w = widgets.find(x => x.id === id);
            if(!w) return;
            w.locked = !w.locked;
            
            if (w.type === 'system') {
                const container = document.getElementById('mainContainer');
                if(w.locked) container.classList.add('locked');
                else container.classList.remove('locked');
            } else {
                if(w.locked) {
                    w.el.classList.add('locked');
                    if(activeWidgetId === id) activateWidgetId(null); // Deselect if active
                } else {
                    w.el.classList.remove('locked');
                }
            }
            renderLayerList();
            playClick();
        }

        function moveLayer(index, direction) {
            // direction 1 = up (forward), -1 = down (backward)
            const newIndex = index + direction;
            
            if (newIndex >= 0 && newIndex < widgets.length) {
                // Swap
                const temp = widgets[index];
                widgets[index] = widgets[newIndex];
                widgets[newIndex] = temp;
                
                updateLayerZIndices();
                renderLayerList();
                playClick();
            }
        }

        function deleteWidgetById(id) {
            const index = widgets.findIndex(w => w.id === id);
            if (index > -1) {
                const w = widgets[index];
                if(w.type === 'system' || w.locked) return; // Cannot delete system or locked
                
                w.el.remove();
                widgets.splice(index, 1);
                if (activeWidgetId === id) activateWidgetId(null);
                renderLayerList();
                playClick();
            }
        }

        function clearAllWidgets() {
            // Remove everything EXCEPT system layer
            widgets = widgets.filter(w => {
                if(w.type === 'system') return true;
                if(w.locked) return true; // Don't clear locked widgets? Or maybe clear all? Standard is clear all usually unlocks or deletes. Let's delete unless locked for safety.
                w.el.remove();
                return false;
            });
            activeWidgetId = null;
            renderLayerList();
            updateLayerZIndices(); // Reset Z of system layer
            playClick();
            showAlert("Unlocked widgets cleared.");
        }

        function activateWidgetId(id) {
            // Deactivate visual
            document.querySelectorAll('.widget').forEach(el => el.classList.remove('active'));
            document.querySelectorAll('.layer-item').forEach(el => el.classList.remove('active-layer'));
            
            activeWidgetId = id;
            
            if (id) {
                const wObj = widgets.find(w => w.id === id);
                if(wObj && wObj.type !== 'system' && !wObj.locked) {
                    wObj.el.classList.add('active');
                    renderLayerList(); // Re-render to show active class in list
                    
                    // Show settings if it's text
                    if(wObj.type === 'text') {
                        activeWidgetSettings.style.display = 'block';
                        widgetTextInput.value = wObj.text;
                        widgetColorInput.value = wObj.color;
                        widgetSizeInput.value = wObj.fontSize;
                    } else {
                        activeWidgetSettings.style.display = 'none';
                    }
                }
            } else {
                activeWidgetSettings.style.display = 'none';
            }
        }

        // --- Active Widget Controls ---
        function updateActiveWidgetText() {
            if(!activeWidgetId) return;
            const wObj = widgets.find(w => w.id === activeWidgetId);
            if(wObj && wObj.type === 'text') {
                const val = widgetTextInput.value;
                wObj.text = val;
                wObj.el.querySelector('.widget-text-content').innerText = val;
            }
        }
        function updateActiveWidgetSize() {
            if(!activeWidgetId) return;
            const wObj = widgets.find(w => w.id === activeWidgetId);
            if(wObj && wObj.type === 'text') {
                const val = widgetSizeInput.value;
                wObj.fontSize = val;
                wObj.el.querySelector('.widget-text-content').style.fontSize = val + 'px';
            }
        }
        function updateActiveWidgetColor() {
            if(!activeWidgetId) return;
            const wObj = widgets.find(w => w.id === activeWidgetId);
            if(wObj && wObj.type === 'text') {
                const val = widgetColorInput.value;
                wObj.color = val;
                wObj.el.querySelector('.widget-text-content').style.color = val;
            }
        }


        // Global Widget Event Listeners
        document.addEventListener('mousedown', handleWidgetStart);
        document.addEventListener('touchstart', handleWidgetStart, {passive: false});
        
        document.addEventListener('mousemove', handleWidgetMove);
        document.addEventListener('touchmove', handleWidgetMove, {passive: false});
        
        document.addEventListener('mouseup', handleWidgetEnd);
        document.addEventListener('touchend', handleWidgetEnd);

        function handleWidgetStart(e) {
            if (e.target.closest('.settings-panel') || e.target.closest('.controls')) return;
            
            // ALLOW TEXT SELECTION / EDITING
            if (e.target.isContentEditable) return;

            const target = e.target;
            const clientX = e.clientX || (e.touches ? e.touches[0].clientX : 0);
            const clientY = e.clientY || (e.touches ? e.touches[0].clientY : 0);

            // 1. DELETE
            if (target.classList.contains('w-delete')) {
                playClick();
                const widget = target.closest('.widget');
                deleteWidgetById(widget.id.replace('w-', ''));
                return;
            }

            // 2. ROTATE
            if (target.classList.contains('w-rotate')) {
                e.preventDefault();
                isRotatingWidget = true;
                const widget = target.closest('.widget');
                const rect = widget.getBoundingClientRect();
                startCenterX = rect.left + rect.width / 2;
                startCenterY = rect.top + rect.height / 2;
                startRotation = parseFloat(widget.dataset.rotation) || 0;
                const dx = clientX - startCenterX;
                const dy = clientY - startCenterY;
                startRotation -= Math.atan2(dy, dx) * (180 / Math.PI) + 90; 
                return;
            }

            // 3. RESIZE
            if (target.classList.contains('w-resize')) {
                e.preventDefault();
                isResizingWidget = true;
                const widget = target.closest('.widget');
                const rect = widget.getBoundingClientRect();
                startCenterX = rect.left + rect.width / 2;
                startCenterY = rect.top + rect.height / 2;
                const dx = clientX - startCenterX;
                const dy = clientY - startCenterY;
                const dist = Math.sqrt(dx*dx + dy*dy);
                startWidth = parseFloat(widget.style.width) || rect.width;
                startHeight = startWidth / dist; 
                return;
            }

            // 4. DRAG / SELECT
            const widget = target.closest('.widget');
            if (widget) {
                const id = widget.id.replace('w-', '');
                const wObj = widgets.find(w => w.id === id);
                if(wObj && wObj.locked) return; // Ignore locked widgets

                activateWidgetId(id);
                isDraggingWidget = true;
                startX = clientX;
                startY = clientY;
                return;
            } else {
                // Clicked background, deselect
                if(!isDraggingWidget && !isResizingWidget && !isRotatingWidget) {
                    activateWidgetId(null);
                }
            }
        }

        function handleWidgetMove(e) {
            if (!activeWidgetId) return;
            const widget = document.getElementById('w-' + activeWidgetId);
            if (!widget) return;

            const clientX = e.clientX || (e.touches ? e.touches[0].clientX : 0);
            const clientY = e.clientY || (e.touches ? e.touches[0].clientY : 0);

            if (isDraggingWidget) {
                e.preventDefault();
                let dx = clientX - startX;
                let dy = clientY - startY;
                
                let newLeft = widget.offsetLeft + dx;
                let newTop = widget.offsetTop + dy;
                
                // SNAP LOGIC
                if (snapToggle.checked) {
                    const snapThreshold = 10;
                    const centerX = window.innerWidth / 2;
                    const centerY = window.innerHeight / 2;
                    
                    // Snap Vertical (X axis center)
                    if (Math.abs(newLeft - centerX) < snapThreshold) {
                        newLeft = centerX;
                        guideV.style.display = 'block';
                    } else {
                        guideV.style.display = 'none';
                    }
                    
                    // Snap Horizontal (Y axis center)
                    if (Math.abs(newTop - centerY) < snapThreshold) {
                        newTop = centerY;
                        guideH.style.display = 'block';
                    } else {
                        guideH.style.display = 'none';
                    }
                } else {
                    guideV.style.display = 'none';
                    guideH.style.display = 'none';
                }

                widget.style.left = newLeft + 'px';
                widget.style.top = newTop + 'px';
                
                startX = clientX;
                startY = clientY;

            } else if (isRotatingWidget) {
                e.preventDefault();
                const dx = clientX - startCenterX;
                const dy = clientY - startCenterY;
                const angle = Math.atan2(dy, dx) * (180 / Math.PI) + 90; 
                const finalAngle = angle + startRotation;
                widget.dataset.rotation = finalAngle;
                widget.style.transform = `translate(-50%, -50%) rotate(${finalAngle}deg)`;
            } else if (isResizingWidget) {
                e.preventDefault();
                const dx = clientX - startCenterX;
                const dy = clientY - startCenterY;
                const dist = Math.sqrt(dx*dx + dy*dy);
                
                let newWidth = dist * 2; 
                if (newWidth < 20) newWidth = 20; 
                
                // For images we change width, for text we might rely on font size control in panel
                // But for consistency let's allow width change for container which wraps text
                // However, standard text scaling is best done via font-size.
                // If it's an image, resize width.
                const wObj = widgets.find(w => w.id === activeWidgetId);
                if(wObj.type === 'image') {
                     widget.style.width = newWidth + 'px';
                } else {
                     // For text, resizing the box via handle feels weird if text doesn't scale.
                     // Let's scale font size based on drag distance?
                     // Or just update width? Updating width for text just changes wrapping.
                     // Let's stick to width for container, user can use panel for font size.
                     widget.style.width = newWidth + 'px';
                }
            }
        }

        function handleWidgetEnd() {
            isDraggingWidget = false;
            isRotatingWidget = false;
            isResizingWidget = false;
            guideV.style.display = 'none';
            guideH.style.display = 'none';
        }

        /* --- LAYOUT SWITCHER --- */
        function changeLayout(mode) {
            playClick();
            document.body.classList.remove('layout-standard', 'layout-inverted', 'layout-split', 'layout-split-rev');
            
            if (mode === 'standard') {
                document.body.classList.add('layout-standard');
                mainTitle.style.textAlign = 'center';
            } else if (mode === 'inverted') {
                document.body.classList.add('layout-inverted');
                mainTitle.style.textAlign = 'center';
            } else if (mode === 'split') {
                document.body.classList.add('layout-split');
            } else if (mode === 'split-rev') {
                document.body.classList.add('layout-split-rev');
            }
        }

        /* --- WORLD CLOCK LOGIC --- */
        function toggleClockMode() {
            isClockMode = clockToggle.checked;
            clockControls.style.display = isClockMode ? 'block' : 'none';
            playClick();

            if (isClockMode) {
                if (isCuberMode) { cuberToggle.checked = false; toggleCuberMode(); }
                if (isPomoMode) { pomoToggle.checked = false; togglePomoMode(); }
                
                timerDisplay.style.display = 'none';
                mainTitle.style.display = 'none';
                scrambleDisplay.style.display = 'none';
                statsDisplay.style.display = 'none';
                
                worldClockContainer.style.display = 'flex';
                updateCitySelection();
                startWorldClock();
            } else {
                worldClockContainer.style.display = 'none';
                stopWorldClock();
                updateLayout();
            }
        }

        function updateCitySelection() {
            const checkboxes = document.querySelectorAll('.city-check');
            selectedCities = [];
            checkboxes.forEach(cb => {
                if(cb.checked) selectedCities.push(cb.value);
            });
            renderCities();
        }

        function renderCities() {
            citiesGrid.innerHTML = '';
            selectedCities.forEach(city => {
                const div = document.createElement('div');
                div.className = 'city-card';
                div.innerHTML = `
                    <div class="city-name">${city}</div>
                    <div class="city-time" id="time-${city}">--:--:--</div>
                    <div class="city-date" id="date-${city}">--</div>
                `;
                citiesGrid.appendChild(div);
            });
            updateClockTick();
        }

        function startWorldClock() {
            updateClockTick();
            clockInterval = setInterval(updateClockTick, 1000);
        }

        function stopWorldClock() {
            clearInterval(clockInterval);
        }

        function updateClockTick() {
            const now = new Date();
            
            // Local Time with Seconds
            localTimeDisplay.innerText = now.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit', second: '2-digit'});
            localDateDisplay.innerText = now.toLocaleDateString([], {weekday: 'short', month: 'short', day: 'numeric'});

            // Cities with Seconds
            selectedCities.forEach(city => {
                const tz = cityTimeZones[city];
                if (!tz) return;
                
                try {
                    const timeStr = now.toLocaleTimeString('en-US', { timeZone: tz, hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit' });
                    const dateStr = now.toLocaleDateString('en-US', { timeZone: tz, month: 'short', day: 'numeric' });
                    
                    const timeEl = document.getElementById(`time-${city}`);
                    const dateEl = document.getElementById(`date-${city}`);
                    if(timeEl) timeEl.innerText = timeStr;
                    if(dateEl) dateEl.innerText = dateStr;
                } catch(e) { console.error(e); }
            });
        }

        /* --- LYRIC SYNC & AUDIO --- */
        function toggleLyricMode() {
            isLyricMode = document.getElementById('lyricToggle').checked;
            lyricControls.style.display = isLyricMode ? 'block' : 'none';
            if (isLyricMode) {
                mainTitle.setAttribute('contenteditable', 'false');
                parseLyrics(); 
            } else {
                stopLyrics();
                if(lyricAudio) { lyricAudio.pause(); lyricAudio.currentTime = lyricStartTime; }
                mainTitle.setAttribute('contenteditable', 'true');
                mainTitle.innerText = "Made by CircleSide with Gemini!";
                mainTitle.style.opacity = 1;
            }
            playClick();
        }

        lyricInput.addEventListener('input', parseLyrics);
        
        // Handle Audio File Upload
        lyricAudioInput.addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) return;
            
            // 1. Setup Audio
            if(lyricAudio) { lyricAudio.pause(); lyricAudio = null; }
            lyricAudio = new Audio(URL.createObjectURL(file));
            lyricAudioStatus.innerText = "Loaded: " + file.name;
            lyricAudioSettings.style.display = 'block'; 
            
            // 2. Init Trimmer on Metadata Load
            lyricAudio.addEventListener('loadedmetadata', () => {
                const dur = lyricAudio.duration;
                lyricTrimStartInput.max = dur;
                lyricTrimDurInput.max = dur;
                lyricTrimStartInput.value = 0;
                lyricTrimDurInput.value = dur;
                
                // Set initial timer
                updateLyricTrim(); 
                
                showAlert("Song Loaded!<br>Trimmer controls unlocked.");
            });

            // 3. Attempt to Extract Lyrics (Simple Text Scan)
            const reader = new FileReader();
            reader.onload = function(ev) {
                const text = ev.target.result;
                const lrcPattern = /\[\d{2}:\d{2}(\.\d{2,3})?\].*/g;
                const matches = text.match(lrcPattern);
                
                if (matches && matches.length > 5) {
                    lyricInput.value = matches.join('\n');
                    parseLyrics();
                    showAlert("Found Embedded Lyrics!");
                }
            };
            reader.readAsText(file, "ISO-8859-1");
        });

        function clearLyricAudio() {
            if(lyricAudio) { lyricAudio.pause(); lyricAudio = null; }
            lyricAudioInput.value = "";
            lyricAudioStatus.innerText = "No file chosen";
            lyricAudioSettings.style.display = 'none';
            showAlert("Song Removed");
        }

        function updateLyricTrim() {
            if(!lyricAudio) return;
            lyricStartTime = parseFloat(lyricTrimStartInput.value);
            lyricDuration = parseFloat(lyricTrimDurInput.value);
            
            if(lyricStartTime + lyricDuration > lyricAudio.duration) {
                lyricDuration = lyricAudio.duration - lyricStartTime;
                lyricTrimDurInput.value = lyricDuration;
            }

            lyricTrimStartVal.innerText = lyricStartTime.toFixed(1) + "s";
            lyricTrimDurVal.innerText = lyricDuration.toFixed(1) + "s";

            if(!isRunning) {
                timeLeft = Math.floor(lyricDuration * 1000);
                originalTime = timeLeft;
                updateDisplay();
            }
        }

        function updateLyricVolume(val) {
            if(lyricAudio) lyricAudio.volume = val / 100;
        }

        function parseLyrics() {
            const raw = lyricInput.value.trim();
            if(!raw) {
                lyricLines = ["Paste Lyrics", "In Settings"];
                isLrcFormat = false;
            } else {
                const lrcRegex = /^\[(\d{2}):(\d{2})(?:\.(\d{2,3}))?\](.*)$/;
                const lines = raw.split('\n');
                const hasTimestamps = lines.some(line => lrcRegex.test(line.trim()));
                
                if (hasTimestamps) {
                    isLrcFormat = true;
                    lyricLines = [];
                    lines.forEach(line => {
                        const match = line.match(lrcRegex);
                        if (match) {
                            const min = parseInt(match[1]);
                            const sec = parseInt(match[2]);
                            const ms = match[3] ? parseInt(match[3]) : 0;
                            const timeVal = min * 60 + sec + (ms / (match[3].length === 3 ? 1000 : 100));
                            lyricLines.push({ time: timeVal, text: match[4].trim() });
                        }
                    });
                    lyricLines.sort((a,b) => a.time - b.time);
                } else {
                    isLrcFormat = false;
                    lyricLines = lines.filter(l => l.trim() !== '');
                }
            }
            if(isLrcFormat) {
                speedControlGroup.style.display = 'none'; lrcStatus.style.display = 'block';
            } else {
                speedControlGroup.style.display = 'flex'; lrcStatus.style.display = 'none';
            }
        }

        function startLyrics() {
            if (!isLyricMode || lyricLines.length === 0) return;
            lyricIndex = 0;
            if (isLrcFormat) { mainTitle.innerText = ""; } 
            else {
                updateSimpleLyric();
                const speed = parseInt(lyricSpeedInput.value) * 1000;
                lyricInterval = setInterval(nextSimpleLyric, speed);
            }
        }

        function stopLyrics() {
            clearInterval(lyricInterval);
            mainTitle.classList.remove('lyric-fade-out', 'lyric-fade-in');
        }

        function nextSimpleLyric() {
            mainTitle.classList.remove('lyric-fade-in'); mainTitle.classList.add('lyric-fade-out');
            setTimeout(() => {
                lyricIndex = (lyricIndex + 1) % lyricLines.length;
                updateSimpleLyric();
                mainTitle.classList.remove('lyric-fade-out'); mainTitle.classList.add('lyric-fade-in');
            }, 300);
        }
        function updateSimpleLyric() { mainTitle.innerText = lyricLines[lyricIndex]; }

        function checkLrcSync(elapsedTime) {
            let activeText = "";
            const absoluteAudioTime = lyricStartTime + elapsedTime;

            for (let i = 0; i < lyricLines.length; i++) {
                if (absoluteAudioTime >= lyricLines[i].time) activeText = lyricLines[i].text; else break;
            }
            
            // Animation Trigger
            if (mainTitle.innerText !== activeText) {
                mainTitle.classList.remove('glitch-active');
                void mainTitle.offsetWidth; // Trigger reflow
                mainTitle.classList.add('glitch-active');
                mainTitle.innerText = activeText;
                setTimeout(() => { mainTitle.classList.remove('glitch-active'); }, 500);
            }
        }

        /* --- CUSTOM ALERT SYSTEM --- */
        function showAlert(msg) { alertMsg.innerHTML = msg; customAlert.classList.add('active'); playClick(); }
        function closeAlert() { customAlert.classList.remove('active'); }

        /* --- FONT ANIMATION --- */
        function changeFont() {
            const selectedFont = fontSelect.value;
            playClick();
            timerDisplay.classList.add('glitch-active');
            mainTitle.classList.add('glitch-active');
            scrambleDisplay.classList.add('glitch-active');
            localTimeDisplay.classList.add('glitch-active');
            
            setTimeout(() => {
                document.documentElement.style.setProperty('--current-font', selectedFont);
                if (selectedFont.includes('Press Start 2P')) document.body.classList.add('retro-mode');
                else document.body.classList.remove('retro-mode');
            }, 200);
            setTimeout(() => {
                timerDisplay.classList.remove('glitch-active');
                mainTitle.classList.remove('glitch-active');
                scrambleDisplay.classList.remove('glitch-active');
                localTimeDisplay.classList.remove('glitch-active');
            }, 550);
        }

        /* --- DRAGGABLE & RESIZABLE LOGIC --- */
        let isDragging = false;
        let dragOffsetX = 0, dragOffsetY = 0;

        panelHeader.addEventListener('mousedown', startDrag);
        panelHeader.addEventListener('touchstart', startDrag, {passive: false});

        function startDrag(e) {
            if(e.target.closest('.close-btn') || e.target.tagName === 'BUTTON') return;
            const rect = settingsPanel.getBoundingClientRect();
            const x = e.clientX || e.touches[0].clientX;
            const y = e.clientY || e.touches[0].clientY;
            if (x > rect.right - 20 || y > rect.bottom - 20 || x < rect.left + 10 || y < rect.top + 10) return; 

            e.preventDefault(); isDragging = true;
            dragOffsetX = x - rect.left; dragOffsetY = y - rect.top;
            
            document.addEventListener('mousemove', dragWindow);
            document.addEventListener('touchmove', dragWindow, {passive: false});
            document.addEventListener('mouseup', stopDrag);
            document.addEventListener('touchend', stopDrag);
        }

        function dragWindow(e) {
            if (!isDragging) return;
            e.preventDefault();
            const x = e.clientX || e.touches[0].clientX;
            const y = e.clientY || e.touches[0].clientY;
            let newLeft = x - dragOffsetX; let newTop = y - dragOffsetY;
            if (newLeft < 0) newLeft = 0; if (newTop < 0) newTop = 0;
            settingsPanel.style.left = `${newLeft}px`; settingsPanel.style.top = `${newTop}px`;
        }

        function stopDrag() {
            isDragging = false;
            document.removeEventListener('mousemove', dragWindow);
            document.removeEventListener('touchmove', dragWindow);
            document.removeEventListener('mouseup', stopDrag);
            document.removeEventListener('touchend', stopDrag);
        }

        /* --- COLORS & PATTERNS --- */
        function updateColors(hex) {
            document.documentElement.style.setProperty('--bg-color', hex);
            const c = hex.replace("#", "");
            const r = parseInt(c.substr(0,2),16), g = parseInt(c.substr(2,2),16), b = parseInt(c.substr(4,2),16);
            const yiq = ((r*299)+(g*587)+(b*114))/1000;
            const contrast = (yiq >= 128) ? '#000000' : '#ffffff';
            document.documentElement.style.setProperty('--text-color', contrast);
            document.documentElement.style.setProperty('--accent', hex);
            
            // ADAPTIVE COLOR LOGIC
            let panelBg, panelText, innerPanelBg, inputBg;
            if(contrast === '#ffffff') {
                // Dark Theme
                panelBg = 'rgba(20, 20, 20, 0.95)';
                panelText = '#ffffff';
                innerPanelBg = 'rgba(255, 255, 255, 0.1)';
                inputBg = 'rgba(0, 0, 0, 0.2)';
            } else {
                // Light Theme
                panelBg = 'rgba(245, 245, 245, 0.95)';
                panelText = '#000000';
                innerPanelBg = 'rgba(0, 0, 0, 0.05)';
                inputBg = 'rgba(255, 255, 255, 0.5)';
            }

            document.documentElement.style.setProperty('--panel-bg', panelBg);
            document.documentElement.style.setProperty('--panel-text', panelText);
            document.documentElement.style.setProperty('--inner-panel-bg', innerPanelBg);
            document.documentElement.style.setProperty('--input-bg', inputBg);
        }
        colorPicker.addEventListener('input', (e) => updateColors(e.target.value));

        function hexToRgba(hex, alphaPercent) {
            const r = parseInt(hex.slice(1, 3), 16), g = parseInt(hex.slice(3, 5), 16), b = parseInt(hex.slice(5, 7), 16);
            return `rgba(${r}, ${g}, ${b}, ${alphaPercent/100})`;
        }

        function updateBgParams() {
            const zoom = sliderZoom.value, panX = sliderPanX.value, panY = sliderPanY.value;
            document.body.style.backgroundPosition = `${panX}% ${panY}%`;
            document.body.style.backgroundSize = currentBgMode === 'image' ? `${zoom}%` : `${zoom}px ${zoom}px`;
        }

        function selectPattern(type) {
            playClick();
            currentBgMode = (type === 'none') ? 'none' : 'pattern';
            currentPatternType = type;
            document.body.classList.remove('custom-image-mode');
            if (type !== 'none') { sliderZoom.value = 30; sliderPanX.value = 50; sliderPanY.value = 50; }
            updatePatternStyle(); updateBgParams();      
        }

        function updatePatternStyle() {
            const blend = blendToggle.checked ? 'overlay' : 'normal';
            document.documentElement.style.setProperty('--bg-blend', blend);
            if (currentBgMode === 'image') return; 
            if (currentPatternType === 'none') { document.body.style.backgroundImage = 'none'; return; }

            const hex = patColorInput.value;
            const op = patOpacityInput.value / 100;
            
            let svg = '';
            const t = currentPatternType;
            if(t==='dots') svg=`<circle cx="10" cy="10" r="5" fill="${hex}" opacity="${op}"/>`;
            else if(t==='stripes') svg=`<path d="M0 20 L20 0 L10 0 L0 10 Z" fill="${hex}" opacity="${op}"/><path d="M10 20 L20 10 L20 20 Z" fill="white" opacity="0.6"/></svg>`;
            else if(t==='grid') svg=`<path d="M10 0 L10 20 M0 10 L20 10" stroke="${hex}" stroke-width="2" opacity="${op}"/>`;
            else if(t==='check') svg=`<rect x="0" y="0" width="10" height="10" fill="${hex}" opacity="${op}"/><rect x="10" y="10" width="10" height="10" fill="${hex}" opacity="${op}"/>`;
            else if(t==='zig') svg=`<path d="M0 0 L10 10 L20 0 L20 5 L10 15 L0 5 Z" fill="${hex}" opacity="${op}"/>`;

            document.body.style.backgroundImage = `url("data:image/svg+xml;utf8,<svg width='20' height='20' xmlns='http://www.w3.org/2000/svg'>${encodeURIComponent(svg)}</svg>")`;
        }

        document.getElementById('bgImageFile').addEventListener('change', function(e) {
            const file = e.target.files[0]; if (!file) return;
            const reader = new FileReader();
            reader.onload = function(ev) {
                currentBgMode = 'image'; sliderZoom.value = 100; sliderPanX.value = 50; sliderPanY.value = 50;
                document.body.style.backgroundImage = `url("${ev.target.result}")`;
                document.body.classList.add('custom-image-mode');
                updatePatternStyle(); updateBgParams(); playClick(); 
                showAlert("Background Image Loaded!");
            }; reader.readAsDataURL(file);
        });

        /* --- TIMER CORE --- */
        function updateLayout() {
            if(isClockMode) {
                mainTitle.style.display = 'none';
                timerDisplay.style.display = 'none';
                return;
            }
            const hasTitle = document.getElementById('titleToggle').checked;
            const showMs = document.getElementById('msToggle').checked || isCuberMode;
            const hasTimer = timerDisplay.innerText.trim() !== "";
            mainTitle.style.display = hasTitle ? 'block' : 'none';
            timerDisplay.style.display = hasTimer ? 'inline-block' : 'none';
            if (showMs) timerDisplay.classList.add('ms-mode'); else timerDisplay.classList.remove('ms-mode');
            
            if (hasTitle && hasTimer) { timerDisplay.classList.add('shrink-mode'); mainTitle.classList.remove('solo-mode'); }
            else if (!hasTitle && hasTimer) { timerDisplay.classList.remove('shrink-mode'); }
            else if (hasTitle && !hasTimer) { mainTitle.classList.add('solo-mode'); }
        }

        function updateDisplay() {
            if (isEditing) return;
            const ts = Math.floor(timeLeft / 1000);
            const m = Math.floor(ts / 60);
            const s = ts % 60;
            const ms = Math.floor((timeLeft % 1000) / 10); 
            let d = `${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
            if (document.getElementById('msToggle').checked || isCuberMode) d += `.${ms.toString().padStart(2, '0')}`;
            timerDisplay.innerText = d;
        }

        function generateScramble() {
            const moves = ['R', 'L', 'U', 'D', 'F', 'B'];
            const modifiers = ['', "'", '2'];
            let scramble = [], lastMove = '';
            for (let i = 0; i < 20; i++) {
                let move; do { move = moves[Math.floor(Math.random() * moves.length)]; } while (move === lastMove);
                lastMove = move;
                scramble.push(move + modifiers[Math.floor(Math.random() * modifiers.length)]);
            }
            scrambleDisplay.textContent = scramble.join(' ');
        }

        function toggleTimer() { 
            if(isClockMode) return; // Disable start/stop in clock mode
            isRunning ? pauseTimer() : startTimer(); 
        }
        
        function startTimer() {
            if (isRunning) return;
            stopAlarm(); 
            if (audioCtx.state === 'suspended') audioCtx.resume();
            if (isEditing) { parseInputTime(); isEditing = false; }
            isRunning = true;
            document.getElementById('toggleBtn').innerText = "Pause";
            lastSecond = Math.floor(timeLeft / 1000);
            const now = Date.now();
            if (isCuberMode) timerStartTime = now - timeLeft; else timerEndTime = now + timeLeft;

            if (isLyricMode) {
                startLyrics();
                if(lyricAudio) {
                    lyricAudio.currentTime = lyricStartTime + (originalTime - timeLeft) / 1000;
                    lyricAudio.play();
                }
            }

            timerInterval = setInterval(() => {
                const now = Date.now();
                let elapsed = 0;

                if (isCuberMode) {
                    timeLeft = now - timerStartTime;
                    elapsed = timeLeft / 1000;
                } else {
                    timeLeft = timerEndTime - now;
                    elapsed = (originalTime - timeLeft) / 1000;

                    if (timeLeft > 0) {
                        const cs = Math.floor(timeLeft / 1000);
                        if (cs < lastSecond) { playTick(); lastSecond = cs; }
                    } else {
                        timeLeft = 0; updateDisplay(); pauseTimer(); playAlarm();
                        
                        // POMODORO AUTO SWITCH
                        if(isPomoMode) {
                            if(pomoState === 'work') {
                                pomoState = 'short';
                                timeLeft = pomoShortTime * 60 * 1000;
                                originalTime = timeLeft;
                                updatePomoUI();
                                showAlert("Break Time! ‚òï<br>Click Start when ready.");
                            } else {
                                pomoState = 'work';
                                timeLeft = pomoWorkTime * 60 * 1000;
                                originalTime = timeLeft;
                                updatePomoUI();
                                showAlert("Back to Work! üí™<br>Click Start.");
                            }
                            updateDisplay();
                        }
                    }
                }
                
                // Lyric Audio Sync Check (Prevent drift)
                if(lyricAudio && !lyricAudio.paused) {
                    const expectedTime = lyricStartTime + elapsed;
                    // If audio drifts more than 0.5s or hasn't started correct segment
                    if(Math.abs(lyricAudio.currentTime - expectedTime) > 0.5) {
                        lyricAudio.currentTime = expectedTime;
                    }
                }

                if(isLyricMode && isLrcFormat && isRunning) checkLrcSync(elapsed);
                
                updateDisplay();
            }, 10);
        }

        function pauseTimer() { 
            clearInterval(timerInterval); 
            isRunning = false; 
            document.getElementById('toggleBtn').innerText = "Start"; 
            stopAlarm();
            if (isLyricMode) {
                stopLyrics();
                if(lyricAudio) lyricAudio.pause();
            }
        }
        
        function resetTimer() {
            if(isClockMode) return;
            pauseTimer(); 
            
            // If lyric mode, reset time based on trim duration, otherwise keep original
            if(isLyricMode && lyricAudio) {
                timeLeft = Math.floor(lyricDuration * 1000);
                originalTime = timeLeft;
                lyricAudio.currentTime = lyricStartTime;
            } else {
                timeLeft = originalTime;
            }

            stopAlarm();
            if (isCuberMode) { 
                timeLeft = 0; 
                generateScramble(); 
                timerDisplay.classList.remove('cuber-stopped'); // Reset red color
            }
            updateDisplay(); if(timerDisplay.innerText === "") { updateDisplay(); updateLayout(); }
        }

        function toggleCuberMode() {
            isCuberMode = cuberToggle.checked; playClick();
            stopAlarm();
            if(isCuberMode) {
                if(isPomoMode) { pomoToggle.checked = false; togglePomoMode(); }
                if(isClockMode) { clockToggle.checked = false; toggleClockMode(); }
                
                pauseTimer(); timeLeft = 0; originalTime = 0; generateScramble();
                scrambleDisplay.style.display = 'block'; updateDisplay();
                statsDisplay.style.display = 'flex'; // Show stats
                timerDisplay.setAttribute('contenteditable', 'false');
                showAlert("Cuber Mode:<br>1. Hold screen/space to Arm.<br>2. Release to Solve.");
            } else {
                scrambleDisplay.style.display = 'none';
                statsDisplay.style.display = 'none'; // Hide stats
                timerDisplay.setAttribute('contenteditable', 'true');
                timeLeft = 300000; originalTime = 300000; updateDisplay();
                timerDisplay.classList.remove('cuber-holding', 'cuber-stopped');
            }
            updateLayout();
        }

        /* --- CUBER HISTORY UI --- */
        function updateLastSolvesUI() {
            statsDisplay.innerHTML = '';
            solveHistory.forEach((solve, index) => {
                const div = document.createElement('div');
                div.className = 'stat-item';
                div.innerHTML = `
                    <div class="stat-header">
                        <span class="stat-index">#${solveHistory.length - index}</span>
                        <span class="stat-time">${solve.time}</span>
                    </div>
                    <div class="stat-scramble">${solve.scramble}</div>
                `;
                statsDisplay.appendChild(div);
            });
        }

        /* --- POMODORO LOGIC --- */
        function togglePomoMode() {
            isPomoMode = pomoToggle.checked;
            pomoControls.style.display = isPomoMode ? 'block' : 'none';
            pomoStatus.style.display = isPomoMode ? 'block' : 'none';
            playClick();

            if (isPomoMode) {
                if(isCuberMode) { cuberToggle.checked = false; toggleCuberMode(); }
                if(isClockMode) { clockToggle.checked = false; toggleClockMode(); }
                
                updatePomoSettings();
                pomoState = 'work';
                timeLeft = pomoWorkTime * 60 * 1000;
                originalTime = timeLeft;
                updatePomoUI();
                updateDisplay();
                timerDisplay.setAttribute('contenteditable', 'false');
            } else {
                timerDisplay.setAttribute('contenteditable', 'true');
                pomoStatus.style.display = 'none';
            }
        }

        function updatePomoSettings() {
            pomoWorkTime = parseInt(pomoWorkInput.value);
            pomoShortTime = parseInt(pomoShortInput.value);
            pomoLongTime = parseInt(pomoLongInput.value);
            if(!isRunning && isPomoMode && pomoState === 'work') {
                timeLeft = pomoWorkTime * 60 * 1000; originalTime = timeLeft; updateDisplay();
            }
        }

        function updatePomoUI() {
            if(pomoState === 'work') {
                pomoStatus.innerText = "üí™ FOCUS MODE";
                pomoStatus.style.color = "#ffffff";
                pomoStatus.style.background = "rgba(231, 76, 60, 0.4)";
            } else if (pomoState === 'short') {
                pomoStatus.innerText = "‚òï SHORT BREAK";
                pomoStatus.style.color = "#ffffff";
                pomoStatus.style.background = "rgba(46, 204, 113, 0.4)";
            } else if (pomoState === 'long') {
                pomoStatus.innerText = "üßò LONG BREAK";
                pomoStatus.style.color = "#ffffff";
                pomoStatus.style.background = "rgba(52, 152, 219, 0.4)";
            }
        }

        function toggleTitleVisibility() { updateLayout(); playClick(); }
        function toggleMsVisibility() { updateLayout(); updateDisplay(); playClick(); }

        /* --- INPUT HANDLERS --- */
        const handleInputDown = (e) => {
            const target = e.target;
            const isControl = target.closest('.controls') || target.closest('.settings-panel') || target.closest('.custom-alert-box') || target.tagName === 'BUTTON' || target.tagName === 'INPUT' || target.tagName === 'SELECT' || target.tagName === 'TEXTAREA';
            const isEditable = target.id === 'timer' || target.id === 'mainTitle';

            // Allow interaction with widgets without triggering timer
            if (target.closest('.widget')) return;

            if (document.body.classList.contains('fullscreen-mode') && !isControl && !isRunning && !isEditable) document.body.classList.toggle('show-controls');
            if (!isCuberMode || isControl || (isEditable && !isCuberMode)) return;

            e.preventDefault();
            if (isRunning) { 
                // STOP TIMER & SAVE STATS
                pauseTimer(); playClick(); document.body.classList.remove('cuber-running');
                
                // Add to history
                const currentScramble = scrambleDisplay.innerText;
                const currentTime = timerDisplay.innerText;
                solveHistory.unshift({ time: currentTime, scramble: currentScramble });
                if(solveHistory.length > 3) solveHistory.pop();
                updateLastSolvesUI();

                timerDisplay.classList.add('cuber-stopped'); // Turn RED
            } else { 
                // START HOLDING (ARMING)
                
                // If coming from a stopped state, generate NEW scramble now
                if (timerDisplay.classList.contains('cuber-stopped')) {
                    generateScramble();
                }

                pauseTimer(); timeLeft = 0; updateDisplay(); 
                timerDisplay.classList.remove('cuber-stopped'); // Remove Red
                timerDisplay.classList.add('not-ready'); 
                holdTimeout = setTimeout(() => { 
                    timerDisplay.classList.remove('not-ready'); 
                    timerDisplay.classList.add('cuber-holding'); // Turn GREEN
                    isArmed = true; 
                    playTick(); 
                }, 300); 
            }
        };

        const handleInputUp = (e) => {
            if (!isCuberMode) return;
            clearTimeout(holdTimeout); 
            timerDisplay.classList.remove('not-ready');
            
            if (isArmed) { 
                // START TIMER
                timerDisplay.classList.remove('cuber-holding'); // Remove Green
                isArmed = false; 
                startTimer(); 
                document.body.classList.add('cuber-running'); 
            } else { 
                timerDisplay.classList.remove('cuber-holding'); // Remove Green if released too early
            }
        };

        document.body.addEventListener('touchstart', handleInputDown, {passive: false});
        document.body.addEventListener('mousedown', handleInputDown);
        document.body.addEventListener('touchend', handleInputUp);
        document.body.addEventListener('mouseup', handleInputUp);

        const forceFocus = (e) => { if(!isCuberMode && !isPomoMode && !isClockMode) e.target.focus(); };
        timerDisplay.addEventListener('click', forceFocus); mainTitle.addEventListener('click', forceFocus);

        /* --- AUDIO & ALARM SYSTEM --- */
        function stopAlarm() {
            clearTimeout(alarmTimeout);
            clearInterval(alarmInterval);
            if (activeAlarmSource) { try { activeAlarmSource.stop(); } catch(e) {} activeAlarmSource = null; }
        }

        function playAlarm() {
            if (volAlarm <= 0) return;
            stopAlarm(); 
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const TOTAL_ALARM_TIME = 5000;

            if (customAlarmBuffer) {
                const start = parseFloat(trimStartInput.value) || 0;
                const dur = parseFloat(trimDurInput.value) || audioDuration;
                
                const playSegment = () => {
                    activeAlarmSource = audioCtx.createBufferSource();
                    const gainNode = audioCtx.createGain();
                    activeAlarmSource.buffer = customAlarmBuffer;
                    gainNode.gain.value = volAlarm;
                    activeAlarmSource.connect(gainNode); gainNode.connect(audioCtx.destination);
                    activeAlarmSource.start(0, start, dur);
                };
                playSegment();
                alarmInterval = setInterval(playSegment, dur * 1000);
                alarmTimeout = setTimeout(stopAlarm, TOTAL_ALARM_TIME);
            } else {
                const playBeepBoop = () => {
                     const now = audioCtx.currentTime;
                     playToneAt(600, 'sine', 1, volAlarm, now);
                     playToneAt(400, 'sine', 1.5, volAlarm, now + 0.4);
                };
                playBeepBoop(); 
                alarmInterval = setInterval(playBeepBoop, 1500); 
                alarmTimeout = setTimeout(stopAlarm, TOTAL_ALARM_TIME);
            }
        }
        
        function playToneAt(f, t, d, v, when) {
             const o = audioCtx.createOscillator(); const g = audioCtx.createGain();
             o.type = t; o.frequency.setValueAtTime(f, when); g.gain.setValueAtTime(v, when);
             g.gain.exponentialRampToValueAtTime(0.0001, when + d);
             o.connect(g); g.connect(audioCtx.destination); o.start(when); o.stop(when + d);
        }

        function playTone(f, t, d, v) { playToneAt(f, t, d, v, audioCtx.currentTime); }
        function playClick() { playTone(800, 'sine', 0.1, volClick); }
        function playTick() { playTone(1000, 'triangle', 0.05, volTick); }
        
        // AUDIO MANIPULATION
        document.getElementById('audioFile').addEventListener('change', function(e) {
            if(e.target.files[0]) {
                const r = new FileReader();
                r.onload = ev => audioCtx.decodeAudioData(ev.target.result, b => { 
                    customAlarmBuffer = b; audioDuration = b.duration;
                    trimmerDiv.style.display = 'flex';
                    trimStartInput.max = audioDuration; trimDurInput.max = audioDuration;
                    trimStartInput.value = 0; trimDurInput.value = audioDuration;
                    trimStartVal.innerText = "0.0s"; trimDurVal.innerText = audioDuration.toFixed(1) + "s";
                    playClick(); showAlert("Alarm Loaded!"); 
                });
                r.readAsArrayBuffer(e.target.files[0]);
            }
        });

        function playCustomPreview() {
             if (volAlarm <= 0) return;
             if (audioCtx.state === 'suspended') audioCtx.resume();
             stopAlarm(); 
             
             if (customAlarmBuffer) {
                 const start = parseFloat(trimStartInput.value);
                 const dur = parseFloat(trimDurInput.value);
                 activeAlarmSource = audioCtx.createBufferSource();
                 const gainNode = audioCtx.createGain();
                 activeAlarmSource.buffer = customAlarmBuffer;
                 gainNode.gain.value = volAlarm;
                 activeAlarmSource.connect(gainNode); gainNode.connect(audioCtx.destination);
                 activeAlarmSource.start(0, start, dur);
             } else {
                 playAlarm(); 
             }
        }

        function clearCustomAudio() {
            customAlarmBuffer = null;
            document.getElementById('audioFile').value = ""; 
            trimmerDiv.style.display = 'none';
            playClick();
            showAlert("Custom Alarm Removed.<br>Reverted to Default.");
        }

        trimStartInput.addEventListener('input', (e) => { trimStartVal.innerText = parseFloat(e.target.value).toFixed(1) + "s"; });
        trimDurInput.addEventListener('input', (e) => { trimDurVal.innerText = parseFloat(e.target.value).toFixed(1) + "s"; });

        /* --- UI CONTROLS --- */
        function toggleSettings() { settingsPanel.classList.toggle('hidden'); }
        function toggleFullScreen() {
            settingsPanel.classList.add('hidden');
            if (!document.fullscreenElement) document.documentElement.requestFullscreen().catch(console.log);
            else if (document.exitFullscreen) document.exitFullscreen();
        }
        document.addEventListener('fullscreenchange', () => {
            if (!document.fullscreenElement) { document.body.classList.remove('fullscreen-mode', 'show-controls'); }
            else { document.body.classList.add('fullscreen-mode'); document.body.classList.remove('show-controls'); }
        });

        /* --- TEXT EDITING --- */
        timerDisplay.addEventListener('focus', () => { if(isCuberMode || isPomoMode || isClockMode) { timerDisplay.blur(); return; } isEditing = true; pauseTimer(); });
        timerDisplay.addEventListener('blur', () => { 
            if(isCuberMode || isPomoMode || isClockMode) return;
            let txt = timerDisplay.innerText.trim();
            if (txt === "") { updateLayout(); isEditing = false; return; }
            let s = 0;
            if (txt.includes(':')) { const p = txt.split(':'); s = (parseInt(p[0])||0)*60 + (parseFloat(p[1])||0); } 
            else { s = parseFloat(txt)||0; }
            timeLeft = Math.floor(s * 1000); originalTime = timeLeft; isEditing = false; updateDisplay(); updateLayout();
        });
        timerDisplay.addEventListener('keydown', (e) => { if (e.key === 'Enter') { e.preventDefault(); timerDisplay.blur(); } });

        window.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
