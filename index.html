<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<link rel="icon" type="image/x-icon" href="favicon.ico">
<title>Tenshon Timer</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=Bangers&family=Caveat&family=Inter:wght@400;800&family=JetBrains+Mono:wght@700&family=Lobster&family=Orbitron:wght@700&family=Oswald:wght@500&family=Pacifico&family=Playfair+Display:wght@700&family=Press+Start+2P&family=Roboto:wght@400;700&display=swap');

:root {
    --bg-color: #3498db;
    --text-color: #ffffff;
    --panel-bg: rgba(20, 20, 20, 0.95); 
    --panel-text: #ffffff;
    --inner-panel-bg: rgba(255, 255, 255, 0.1); 
    --input-bg: rgba(0, 0, 0, 0.2);
    --accent: #3498db;
    --bg-blend: overlay;
    --current-font: 'Inter', sans-serif;
    --guide-color: #ff00ff;
}

body {
    margin: 0;
    height: 100vh;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    background-color: var(--bg-color);
    background-repeat: repeat;
    background-position: center;
    background-blend-mode: var(--bg-blend);
    color: var(--text-color);
    font-family: var(--current-font);
    transition: background-color 0.5s ease, color 0.5s ease;
    text-align: center;
    overflow: hidden;
    user-select: none;
    -webkit-user-select: none;
    -webkit-tap-highlight-color: transparent;
    touch-action: manipulation;
}

body.custom-image-mode { background-repeat: no-repeat !important; }

.container {
    position: absolute;
    top: 0; left: 0;
    z-index: 50; /* Default high, managed by JS now */
    width: 100%;
    height: 100%;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    transition: gap 0.3s ease;
    pointer-events: none; /* Allows clicking through empty space */
}

.container > * { pointer-events: auto; }
.container.locked > * { pointer-events: none !important; }

/* --- LAYOUT MODES --- */
body.layout-inverted .container { flex-direction: column-reverse; }

body.layout-split .container { flex-direction: row; gap: 5vw; padding: 0 5vw; box-sizing: border-box;}
body.layout-split .timer-display { font-size: 15vw; }
body.layout-split h1 { text-align: right; }

body.layout-split-rev .container { flex-direction: row-reverse; gap: 5vw; padding: 0 5vw; box-sizing: border-box;}
body.layout-split-rev .timer-display { font-size: 15vw; }
body.layout-split-rev h1 { text-align: left; }

@media (max-width: 768px) {
    body.layout-split .container, body.layout-split-rev .container { 
        flex-direction: column !important; 
        gap: 0;
    }
    body.layout-split .timer-display, body.layout-split-rev .timer-display { 
        font-size: 22vw; 
    }
    body.layout-split h1, body.layout-split-rev h1 { text-align: center; }
}

/* --- CLOCK LAYOUT ADAPTATIONS --- */
body.layout-split .world-clock-container,
body.layout-split-rev .world-clock-container {
    width: 50%;
    flex: 1;
}
body.layout-split .local-time, 
body.layout-split-rev .local-time {
    font-size: 9vw; /* Smaller in split mode */
}
body.layout-split h1, 
body.layout-split-rev h1 {
    flex: 1;
    width: auto;
    max-width: 45%;
}

/* --- WIDGET LAYER --- */
#widgetLayer {
    position: absolute;
    top: 0; left: 0; width: 100%; height: 100%;
    z-index: auto; 
    pointer-events: none; 
    overflow: hidden;
}

.widget {
    position: absolute;
    cursor: grab;
    user-select: none;
    touch-action: none;
    transform-origin: center center;
    display: flex; justify-content: center; align-items: center;
    pointer-events: auto; 
    box-sizing: border-box;
    min-width: 20px; min-height: 20px;
}
.widget:active { cursor: grabbing; }
.widget.locked { pointer-events: none !important; }

.widget img {
    width: 100%; height: 100%;
    object-fit: contain;
    pointer-events: none;
    display: block;
}

.widget-text-content {
    font-size: 50px; /* Base size, overridden by JS */
    white-space: pre-wrap; /* Allow multiline and wrapping */
    font-weight: bold;
    text-shadow: 0 2px 5px rgba(0,0,0,0.3);
    pointer-events: none;
    line-height: 1;
    outline: none;
    min-width: 30px;
}

/* EDIT MODE STYLES */
.widget-text-content[contenteditable="true"] {
    pointer-events: auto;
    cursor: text;
    background: rgba(0,0,0,0.2);
    border-radius: 4px;
    padding: 2px 5px;
    border: 1px dashed rgba(255,255,255,0.5);
}

.widget.active { outline: 2px dashed rgba(255,255,255,0.8); }

.widget-controls {
    position: absolute; top: 0; left: 0; width: 100%; height: 100%;
    pointer-events: none; display: none;
}
.widget.active .widget-controls { display: block; }

.w-handle {
    position: absolute; width: 24px; height: 24px; /* Larger touch target */
    background: #3498db; border: 2px solid #fff; border-radius: 50%;
    pointer-events: auto; box-shadow: 0 2px 5px rgba(0,0,0,0.3);
    z-index: 30;
}

.w-resize { bottom: -12px; right: -12px; cursor: nwse-resize; }

.w-rotate {
    top: -30px; left: 50%; transform: translateX(-50%);
    background: #2ecc71; cursor: grab;
}
.w-rotate:active { cursor: grabbing; }
.w-rotate::after {
    content: ''; position: absolute; top: 22px; left: 9px;
    width: 2px; height: 10px; background: rgba(255,255,255,0.5);
}

.w-delete {
    position: absolute; top: -12px; left: -12px;
    background: #e74c3c; color: white;
    display: flex; justify-content: center; align-items: center;
    font-size: 14px; font-weight: bold; cursor: pointer;
}

/* --- SNAP GUIDES --- */
.guide-line {
    position: absolute;
    background-color: var(--guide-color);
    display: none;
    pointer-events: none;
    z-index: 9999;
    box-shadow: 0 0 5px var(--guide-color);
}
.guide-v { width: 1px; height: 100%; top: 0; left: 50%; transform: translateX(-50%); }
.guide-h { height: 1px; width: 100%; top: 50%; left: 0; transform: translateY(-50%); }

/* --- ELECTRICITY ANIMATION --- */
@keyframes electric-change {
    0% { text-shadow: 0 0 0 rgba(0, 255, 255, 0); transform: translate(0,0); }
    10% { text-shadow: 0 0 10px rgba(0, 255, 255, 0.8), 0 0 20px rgba(0, 255, 255, 0.6); color: #fff; transform: translate(-1px, 1px); }
    25% { text-shadow: 0 0 15px rgba(0, 255, 255, 1), 0 0 30px rgba(0, 255, 255, 0.8); color: #e0ffff; transform: translate(2px, -1px); }
    40% { text-shadow: 0 0 5px rgba(0, 255, 255, 0.6); color: #fff; transform: translate(-2px, 0); }
    60% { text-shadow: 0 0 10px rgba(0, 255, 255, 0.4); transform: translate(1px, 2px); }
    100% { text-shadow: 0 4px 8px rgba(0,0,0,0.2); color: var(--text-color); transform: translate(0,0); }
}

.glitch-active { animation: electric-change 0.5s ease-out both; }

/* Scramble Text */
.scramble-display {
    font-family: 'JetBrains Mono', monospace;
    font-size: 3vh; 
    margin-bottom: 2vh;
    max-width: 95%;
    line-height: 1.2;
    display: none;
    opacity: 0.9;
    font-weight: bold;
    text-shadow: 0 2px 4px rgba(0,0,0,0.5);
    pointer-events: none;
    text-align: center;
    word-wrap: break-word;
}

/* Stats / Last Solves List */
.stats-container {
    display: none;
    flex-direction: column;
    gap: 10px;
    margin-top: 3vh;
    width: 85%;
    max-height: 25vh;
    overflow-y: auto;
    pointer-events: none;
}

.stat-item {
    background: rgba(0, 0, 0, 0.3);
    padding: 8px 15px;
    border-radius: 12px;
    text-shadow: 0 1px 2px rgba(0,0,0,0.5);
    text-align: left;
    display: flex;
    flex-direction: column;
    animation: slideIn 0.3s ease-out;
}

@keyframes slideIn { from { opacity: 0; transform: translateY(-10px); } to { opacity: 1; transform: translateY(0); } }

.stat-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 4px;
}

.stat-time {
    font-family: 'JetBrains Mono', monospace;
    font-size: 2.2vh;
    color: #2ecc71;
    font-weight: bold;
}

.stat-index {
    font-size: 1.5vh;
    opacity: 0.6;
    font-weight: bold;
}

.stat-scramble {
    font-family: 'JetBrains Mono', monospace;
    font-size: 1.4vh;
    color: rgba(255, 255, 255, 0.8);
    word-wrap: break-word;
    line-height: 1.1;
}

/* POMODORO STATUS */
.pomo-status {
    font-family: 'JetBrains Mono', monospace;
    font-size: 1rem;
    text-transform: uppercase;
    letter-spacing: 2px;
    background: rgba(255,255,255,0.2);
    padding: 5px 15px;
    border-radius: 20px;
    margin-bottom: 2vh;
    display: none;
    backdrop-filter: blur(5px);
    font-weight: bold;
    animation: fadeIn 0.5s ease;
}
@keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }

/* WORLD CLOCK */
.world-clock-container {
    display: none;
    flex-direction: column;
    align-items: center;
    width: 100%;
    max-height: 80vh;
    overflow-y: auto;
}

.local-time-wrapper { margin-bottom: 20px; }
.local-time {
    font-size: 13vw; 
    font-weight: bold;
    line-height: 1;
    text-shadow: 0 4px 8px rgba(0,0,0,0.2);
    font-variant-numeric: tabular-nums;
}
.local-date {
    font-size: 4vw;
    opacity: 0.8;
    margin-top: 5px;
    text-transform: uppercase;
    letter-spacing: 2px;
}

.cities-grid {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    gap: 15px;
    width: 90%;
    max-width: 1000px;
}

.city-card {
    background: rgba(0,0,0,0.3);
    backdrop-filter: blur(5px);
    padding: 10px 20px;
    border-radius: 10px;
    min-width: 140px; 
    text-align: center;
    border: 1px solid rgba(255,255,255,0.1);
}
.city-name { font-size: 0.8rem; opacity: 0.7; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 5px; }
.city-time { font-size: 1.2rem; font-weight: bold; font-variant-numeric: tabular-nums; }
.city-date { font-size: 0.6rem; opacity: 0.5; }

h1 {
    font-size: 5vw;
    margin: 0;
    outline: none;
    border: 1px solid transparent;
    cursor: text;
    display: none;
    padding: 0 10px;
    border-radius: 10px;
    line-height: 1.2;
    width: 80%;
    max-width: 90%; 
    text-shadow: 0 2px 4px rgba(0,0,0,0.3);
    font-family: inherit;
    white-space: pre-wrap; 
    word-wrap: break-word;
    user-select: text;
    -webkit-user-select: text;
    pointer-events: auto;
    transition: opacity 0.3s ease, transform 0.3s ease;
}

h1.lyric-fade-out { opacity: 0; transform: translateY(-5px); }
h1.lyric-fade-in { opacity: 1; transform: translateY(0); }

h1.solo-mode { font-size: 10vw; display: block; }
h1:hover { background: rgba(255,255,255,0.1); }
h1:focus { background: rgba(255,255,255,0.2); border-bottom: 2px solid var(--text-color); }

/* --- TIMER --- */
.timer-display {
    font-weight: bold;
    font-variant-numeric: tabular-nums; 
    cursor: text; 
    line-height: 1;
    outline: none;
    border-bottom: 2px solid transparent;
    display: inline-block;
    transition: font-size 0.3s ease, color 0.1s;
    text-shadow: 0 4px 8px rgba(0,0,0,0.2);
    font-family: inherit;
    white-space: nowrap; 
    user-select: text;
    -webkit-user-select: text;
    pointer-events: auto;
    font-size: 22vw; 
}

/* CUBER MODE COLORS - FIXED */
.timer-display.cuber-holding { 
    color: #2ecc71 !important; /* GREEN */
    transition: none !important;
}
.timer-display.cuber-stopped { 
    color: #e74c3c !important; /* RED */
    transition: none !important;
}

.timer-display.ms-mode { font-size: 14vw; }

body.retro-mode h1 { font-size: 3vw !important; }
body.retro-mode .timer-display { font-size: 15vw !important; letter-spacing: -2px; }
body.retro-mode .timer-display.ms-mode { font-size: 9vw !important; letter-spacing: -3px; }
body.retro-mode .local-time { font-size: 8vw !important; }

body.fullscreen-mode .timer-display { font-size: 30vw; }
body.fullscreen-mode .timer-display.ms-mode { font-size: 18vw !important; }
body.fullscreen-mode.retro-mode .timer-display { font-size: 20vw !important; }
body.fullscreen-mode.retro-mode .timer-display.ms-mode { font-size: 12vw !important; }

/* --- DRAGGABLE SETTINGS PANEL --- */
.settings-panel {
    position: fixed;
    top: 15%;
    left: 5%;
    width: 350px;
    height: 600px;
    background-color: var(--panel-bg); 
    color: var(--panel-text);
    backdrop-filter: blur(20px);
    -webkit-backdrop-filter: blur(20px);
    border-radius: 15px;
    display: flex;
    flex-direction: column;
    box-shadow: 0 20px 50px rgba(0,0,0,0.7);
    z-index: 1000;
    border: 1px solid rgba(128, 128, 128, 0.4); 
    font-family: 'Segoe UI', sans-serif;
    resize: both; 
    overflow: hidden;
    min-width: 300px;
    min-height: 400px;
    max-width: 90vw;
    max-height: 90vh;
}

.settings-panel.hidden { opacity: 0; pointer-events: none; transform: scale(0.95); transition: opacity 0.2s, transform 0.2s; }

.panel-header {
    padding: 12px 15px;
    background: var(--inner-panel-bg); 
    cursor: grab;
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-weight: bold;
    border-bottom: 1px solid rgba(128,128,128,0.3);
    flex-shrink: 0;
    font-size: 1rem;
    letter-spacing: 0.5px;
}
.panel-header:active { cursor: grabbing; }

.close-btn { background: none; border: none; font-size: 1.2rem; cursor: pointer; color: inherit; padding: 0 8px; transition: color 0.2s; }
.close-btn:hover { color: #ff5555; }

.panel-content {
    padding: 15px;
    overflow-y: auto;
    flex-grow: 1;
    display: flex;
    flex-direction: column;
    gap: 15px;
}

.panel-content::-webkit-scrollbar { width: 6px; }
.panel-content::-webkit-scrollbar-thumb { background: rgba(128,128,128,0.5); border-radius: 3px; }

.settings-section {
    background: var(--inner-panel-bg); 
    padding: 10px;
    border-radius: 8px;
    border: 1px solid rgba(128,128,128,0.1);
    transition: all 0.3s ease;
}

/* DRAGGING STYLES */
.settings-section.dragging {
    opacity: 0.6;
    background: rgba(255,255,255,0.05);
    border: 1px dashed rgba(255,255,255,0.5);
    pointer-events: none; 
}

.section-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    cursor: grab;
    padding: 5px 0;
    user-select: none;
}
.section-header:active { cursor: grabbing; }
.section-header:hover { opacity: 0.8; }

.section-title {
    text-transform: uppercase; letter-spacing: 1px; opacity: 0.7;
    font-size: 0.75rem; font-weight: bold;
    display: flex; align-items: center; gap: 5px;
    margin-bottom: 0;
    pointer-events: none;
}

.section-arrow {
    font-size: 0.7rem;
    opacity: 0.5;
    transition: transform 0.2s;
    margin-left: auto;
    margin-right: 5px;
}

.settings-section.collapsed .section-arrow { transform: rotate(-90deg); }

.section-content {
    margin-top: 10px;
    display: block;
    animation: fadeInContent 0.2s;
}

.settings-section.collapsed .section-content { display: none; }
@keyframes fadeInContent { from { opacity: 0; transform: translateY(-5px); } to { opacity: 1; transform: translateY(0); } }

/* Detached Window Styles */
.settings-section.detached {
    position: fixed;
    z-index: 1002;
    box-shadow: 0 10px 30px rgba(0,0,0,0.7);
    border: 1px solid rgba(128,128,128,0.4);
    background-color: var(--panel-bg); 
    backdrop-filter: blur(20px);
    -webkit-backdrop-filter: blur(20px);
    resize: both;
    overflow: hidden;
    min-width: 250px;
    max-width: 90vw;
    max-height: 80vh;
    display: flex;
    flex-direction: column;
    top: 20%; left: 20%; /* Default pos, overridden by JS */
    width: 300px;
    pointer-events: auto !important; /* Ensure detached is interactive */
}

.settings-section.detached.dragging { pointer-events: none !important; }

.settings-section.detached .section-content {
    display: block !important;
    overflow-y: auto;
    flex-grow: 1;
    padding-right: 5px;
}

.window-controls { display: flex; align-items: center; gap: 5px; }

.dock-btn, .min-btn {
    display: none;
    background: none; border: none; color: inherit; cursor: pointer; font-weight: bold;
    font-size: 1rem; padding: 0 5px; opacity: 0.8; transition: opacity 0.2s;
}
.dock-btn:hover, .min-btn:hover { opacity: 1; color: var(--accent); }

.settings-section.detached .dock-btn, .settings-section.detached .min-btn { display: block; }
.settings-section.detached .section-arrow { display: none; }
.settings-section.detached .section-header { border-bottom: 1px solid rgba(128,128,128,0.2); padding-bottom: 8px; margin-bottom: 8px;}

/* Minimized State */
.settings-section.minimized { display: none !important; }

/* Placeholder style */
.section-placeholder {
    border: 2px dashed rgba(255,255,255,0.1);
    border-radius: 8px;
    margin-bottom: 15px;
    height: 40px; 
    background: rgba(0,0,0,0.1);
}

select, .custom-file-upload, textarea, input[type="number"], input[type="text"] {
    width: 100%; padding: 8px; border-radius: 6px;
    border: 1px solid rgba(128,128,128,0.5); 
    background: var(--input-bg); 
    color: inherit; font-weight: bold; cursor: pointer; outline: none;
    font-size: 0.85rem; box-sizing: border-box;
    font-family: inherit;
}
textarea { resize: vertical; min-height: 80px; font-weight: normal; font-size: 0.8rem; line-height: 1.4; white-space: pre; }
select option { background: #222; color: white; }

.toggle-row { display: flex; justify-content: space-between; align-items: center; width: 100%; cursor: pointer; padding: 5px 0; }
.toggle-row:hover label { opacity: 1; }
.toggle-row label { cursor: pointer; flex-grow: 1; opacity: 0.8; font-size: 0.9rem; }
input[type="checkbox"] { width: 18px; height: 18px; cursor: pointer; accent-color: var(--accent); }

.slider-group { display: flex; align-items: center; justify-content: space-between; gap: 10px; margin-bottom: 5px; }
.slider-group label { font-size: 0.8rem; opacity: 0.8; width: 60px; flex-shrink: 0; }
input[type="range"] { 
    flex-grow: 1; cursor: pointer; accent-color: var(--accent); 
    height: 6px; 
    background: rgba(128, 128, 128, 0.4); 
    border-radius: 3px; 
    appearance: none;
    -webkit-appearance: none;
}
input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    height: 16px; width: 16px;
    background: var(--panel-text);
    border-radius: 50%;
    cursor: pointer;
    box-shadow: 0 1px 3px rgba(0,0,0,0.3);
}

input[type="number"].slider-val {
    width: 45px;
    flex-shrink: 0;
    padding: 2px 5px;
    margin-left: 5px;
    text-align: center;
    background: var(--input-bg); 
    font-size: 0.75rem;
    -moz-appearance: textfield;
}
input[type="number"].slider-val::-webkit-outer-spin-button,
input[type="number"].slider-val::-webkit-inner-spin-button {
    -webkit-appearance: none;
    margin: 0;
}

.pattern-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 6px; margin-bottom: 10px; }
.pattern-btn {
    height: 40px; border-radius: 6px; border: 1px solid rgba(255,255,255,0.2);
    cursor: pointer; transition: transform 0.1s, border-color 0.2s;
    background-color: #222 !important; background-size: cover; background-position: center !important; 
}
.pattern-btn:hover { transform: scale(1.02); border-color: var(--accent); }

.pat-none { background: #222; position: relative; }
.pat-none::after { content: 'üö´'; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); }
.pat-dots { background-image: url('data:image/svg+xml;utf8,<svg width="20" height="20" xmlns="http://www.w3.org/2000/svg"><circle cx="10" cy="10" r="4" fill="white" opacity="0.8"/></svg>'); }
.pat-stripes { background-image: url('data:image/svg+xml;utf8,<svg width="20" height="20" xmlns="http://www.w3.org/2000/svg"><path d="M0 20 L20 0 L10 0 L0 10 Z" fill="white" opacity="0.6"/><path d="M10 20 L20 10 L20 20 Z" fill="white" opacity="0.6"/></svg>'); }
.pat-grid { background-image: url('data:image/svg+xml;utf8,<svg width="20" height="20" xmlns="http://www.w3.org/2000/svg"><path d="M10 0 L10 20 M0 10 L20 10" stroke="white" stroke-width="2" opacity="0.8"/></svg>'); }
.pat-check { background-image: url('data:image/svg+xml;utf8,<svg width="20" height="20" xmlns="http://www.w3.org/2000/svg"><rect x="0" y="0" width="10" height="10" fill="white" opacity="0.5"/><rect x="10" y="10" width="10" height="10" fill="white" opacity="0.5"/></svg>'); }
.pat-zig { background-image: url('data:image/svg+xml;utf8,<svg width="20" height="20" xmlns="http://www.w3.org/2000/svg"><path d="M0 0 L10 10 L20 0 L20 5 L10 15 L0 5 Z" fill="white" opacity="0.6"/></svg>'); }

/* Layout Buttons */
.layout-btn {
    height: 40px; border-radius: 6px; border: 1px solid rgba(255,255,255,0.2);
    cursor: pointer; transition: transform 0.1s, border-color 0.2s;
    background: rgba(0,0,0,0.3); display: flex; flex-direction: column; justify-content: center; align-items: center; gap: 2px;
}
.layout-btn:hover { transform: scale(1.02); border-color: var(--accent); }
.l-box { background: rgba(255,255,255,0.8); width: 15px; height: 6px; border-radius: 1px; }
.l-line { background: rgba(255,255,255,0.4); width: 20px; height: 2px; border-radius: 1px; }

input[type="file"] { display: none; }
.file-label {
    display: block; width: 100%; text-align: center; padding: 8px; 
    background: var(--input-bg); border-radius: 6px; font-size: 0.8rem; 
    cursor: pointer; transition: background 0.2s; box-sizing: border-box;
    border: 1px solid rgba(128,128,128,0.2);
}
.file-label:hover { background: rgba(128,128,128,0.2); }
.btn-delete { background: #e74c3c; color: #fff; margin-top:5px; border:none; padding:8px; border-radius:6px; cursor:pointer; width:100%; font-weight:bold; }
.btn-delete:hover { background: #c0392b; }
.btn-add-text { background: #9b59b6; color: #fff; border:none; padding:8px; border-radius:6px; cursor:pointer; width:100%; font-weight:bold; }
.btn-add-text:hover { background: #8e44ad; }

.audio-actions { display: flex; gap: 5px; margin-top: 5px; }
.audio-btn { flex: 1; padding: 6px; font-size: 0.75rem; border-radius: 4px; border:none; cursor: pointer; font-weight: bold; opacity: 0.8; transition: opacity 0.2s;}
.audio-btn:hover { opacity: 1; }
.btn-test { background: #2ecc71; color: #fff; }
.btn-clear { background: #e74c3c; color: #fff; }

.audio-trimmer {
    background: var(--inner-panel-bg); 
    padding: 10px; border-radius: 6px;
    display: none; flex-direction: column; gap: 8px; margin-top: 5px;
}
.trim-info { display: flex; justify-content: space-between; font-size: 0.7rem; opacity: 0.7; }

.controls {
    position: fixed; bottom: 20px; background: var(--panel-bg); backdrop-filter: blur(10px);
    padding: 10px 20px; border-radius: 50px; display: flex; gap: 10px; align-items: center;
    flex-wrap: wrap; justify-content: center; box-shadow: 0 4px 6px rgba(0,0,0,0.1);
    transition: opacity 0.3s ease, transform 0.3s ease; z-index: 100;
    resize: both; overflow: hidden; min-width: 320px; max-width: 90vw;
}

body.fullscreen-mode .controls { opacity: 0; pointer-events: none; transform: translateY(30px); }
body.fullscreen-mode.show-controls .controls { opacity: 1; pointer-events: auto; transform: translateY(0); }
body.fullscreen-mode:not(.show-controls) .settings-panel { opacity: 0 !important; pointer-events: none !important; }
body.cuber-running .controls, body.cuber-running .settings-panel { opacity: 0 !important; pointer-events: none !important; }

button.main-btn {
    padding: 8px 16px; border: none; border-radius: 20px; font-weight: bold; cursor: pointer;
    background-color: var(--panel-text); color: var(--panel-bg); transition: transform 0.1s;
    font-size: 0.9rem; min-width: 40px;
}
button.main-btn:active { transform: scale(0.95); }
input[type="color"] { border: none; width: 35px; height: 35px; cursor: pointer; background: none; padding: 0; }

.custom-alert-box {
    position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
    background-color: var(--panel-bg); color: var(--panel-text); padding: 20px;
    border-radius: 15px; box-shadow: 0 10px 40px rgba(0,0,0,0.6);
    border: 1px solid rgba(128, 128, 128, 0.4); backdrop-filter: blur(20px);
    z-index: 2000; min-width: 250px; text-align: center; opacity: 0; pointer-events: none;
    transition: opacity 0.3s; display: flex; flex-direction: column; gap: 15px;
}
.custom-alert-box.active { opacity: 1; pointer-events: auto; }
.alert-ok-btn {
    background: rgba(255,255,255,0.1); color: inherit; border: 1px solid rgba(128,128,128,0.5);
    padding: 8px 20px; border-radius: 10px; cursor: pointer; font-weight: bold; align-self: center;
}

/* --- LAYERS PANEL STYLES --- */
#layersList {
    display: flex; flex-direction: column; gap: 5px;
    max-height: 200px; overflow-y: auto; padding: 5px;
    background: rgba(0,0,0,0.2); border-radius: 6px;
}
.layer-item {
    display: flex; align-items: center; gap: 10px;
    padding: 5px 10px; background: rgba(255,255,255,0.05);
    border-radius: 4px; cursor: pointer; transition: background 0.2s;
    border: 1px solid transparent;
}
.layer-item:hover { background: rgba(255,255,255,0.1); }
.layer-item.active-layer { border-color: var(--accent); background: rgba(255,255,255,0.15); }
.layer-item.system-layer { background: rgba(52, 152, 219, 0.2); }

.layer-thumb { width: 30px; height: 30px; object-fit: cover; border-radius: 4px; background: #000; }
.layer-icon-text { width: 30px; height: 30px; display: flex; align-items: center; justify-content: center; background: #555; border-radius: 4px; font-size: 1.2rem; }
.layer-name { flex-grow: 1; font-size: 0.8rem; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; text-align: left; }

.layer-controls { display: flex; gap: 2px; }
.layer-btn { 
    background: none; border: 1px solid rgba(255,255,255,0.2); color: inherit; 
    width: 24px; height: 24px; border-radius: 4px; cursor: pointer;
    display: flex; align-items: center; justify-content: center; font-size: 0.7rem;
}
.layer-btn:hover { background: rgba(255,255,255,0.2); }
.layer-btn.btn-del-layer:hover { background: #e74c3c; border-color: #e74c3c; }

.layer-btn.locked { color: #e74c3c; }

.no-layers { font-size: 0.8rem; opacity: 0.5; padding: 10px; text-align: center; }

#activeWidgetSettings { display: none; margin-top: 10px; border-top: 1px solid rgba(128,128,128,0.2); padding-top: 10px; }
</style>
</head>
<body>

<div id="widgetLayer"></div>

<div id="guide-v" class="guide-line guide-v"></div>
<div id="guide-h" class="guide-line guide-h"></div>

<div class="container" id="mainContainer">
    <div id="pomoStatus" class="pomo-status">üí™ FOCUS MODE</div>

    <div id="scrambleDisplay" class="scramble-display"></div>
    <h1 id="mainTitle" contenteditable="true" spellcheck="false">Made by CircleSide with Gemini!</h1>
    <div class="timer-display" id="timer" contenteditable="true" spellcheck="false">05:00</div>
    
    <div id="statsDisplay" class="stats-container"></div>
    
    <div id="worldClockContainer" class="world-clock-container">
        <div class="local-time-wrapper">
            <div id="localTime" class="local-time">12:00:00</div>
            <div id="localDate" class="local-date">Mon, Jan 1</div>
        </div>
        <div id="citiesGrid" class="cities-grid">
        </div>
    </div>
</div>

<div id="customAlert" class="custom-alert-box">
    <div id="alertMsg" style="font-size:1rem; line-height:1.4;"></div>
    <button class="alert-ok-btn" onclick="closeAlert()">OK</button>
</div>

<div id="settingsPanel" class="settings-panel hidden">
    <div class="panel-header" id="panelHeader">
        <span>‚öôÔ∏è Settings</span>
        <button class="close-btn" onclick="toggleSettings()">‚úñ</button>
    </div>

    <div class="panel-content" id="panelContent">
        <div class="settings-section" id="sec-data">
            <div class="section-header">
                <div class="section-title">üíæ Data</div>
                <div class="section-arrow">‚ñº</div>
                <div class="window-controls">
                    <button class="min-btn" onclick="minimizeSection('sec-data')" title="Minimize">_</button>
                    <button class="dock-btn" onclick="dockSection('sec-data')" title="Dock">‚úï</button>
                </div>
            </div>
            <div class="section-content">
                <div style="display:flex; gap:5px;">
                    <button class="main-btn" onclick="saveConfig()" style="flex:1;">Save Config</button>
                    <label class="main-btn" style="flex:1; text-align:center; cursor:pointer;">
                        Load Config
                        <input type="file" id="loadConfigFile" accept=".json" onchange="loadConfig(this)" style="display:none;">
                    </label>
                </div>
            </div>
        </div>

        <div class="settings-section" id="sec-quick">
            <div class="section-header">
                <div class="section-title">‚ö° Quick Access Toolbar</div>
                <div class="section-arrow">‚ñº</div>
                <div class="window-controls">
                    <button class="min-btn" onclick="minimizeSection('sec-quick')" title="Minimize">_</button>
                    <button class="dock-btn" onclick="dockSection('sec-quick')" title="Dock">‚úï</button>
                </div>
            </div>
            <div class="section-content">
                <div class="toggle-row">
                    <label>üßä Cuber Mode</label> <input type="checkbox" class="qa-check" value="cuber" onchange="updateQuickAccess()">
                </div>
                <div class="toggle-row">
                    <label>üçÖ Pomodoro</label> <input type="checkbox" class="qa-check" value="pomo" onchange="updateQuickAccess()">
                </div>
                <div class="toggle-row">
                    <label>üéµ Lyric Sync</label> <input type="checkbox" class="qa-check" value="lyric" onchange="updateQuickAccess()">
                </div>
                <div class="toggle-row">
                    <label>üåé World Clock</label> <input type="checkbox" class="qa-check" value="clock" onchange="updateQuickAccess()">
                </div>
                <!-- NEW ITEMS -->
                <div class="toggle-row">
                    <label>üêô GitHub</label> <input type="checkbox" class="qa-check" value="github" checked onchange="updateQuickAccess()">
                </div>
                <div class="toggle-row">
                    <label>‚òï Ko-fi</label> <input type="checkbox" class="qa-check" value="kofi" checked onchange="updateQuickAccess()">
                </div>
            </div>
        </div>

        <div class="settings-section" id="sec-layers">
            <div class="section-header">
                <div class="section-title">‚â° Layers</div>
                <div class="section-arrow">‚ñº</div>
                <div class="window-controls">
                    <button class="min-btn" onclick="minimizeSection('sec-layers')" title="Minimize">_</button>
                    <button class="dock-btn" onclick="dockSection('sec-layers')" title="Dock">‚úï</button>
                </div>
            </div>
            <div class="section-content">
                <div id="layersList">
                    <div class="no-layers">No widgets added</div>
                </div>
                
                <div id="activeWidgetSettings">
                    <div class="section-title" style="margin-bottom:5px; opacity:0.8;">Widget Settings</div>
                    <div id="textWidgetControls">
                        <input type="text" id="widgetTextInput" placeholder="Edit Text" oninput="updateActiveWidgetText()" style="margin-bottom:5px;">
                        <div class="slider-group">
                            <label>Size</label>
                            <input type="range" id="widgetSizeInput" min="10" max="300" oninput="updateActiveWidgetSize()">
                        </div>
                        <div class="slider-group">
                            <label>Color</label>
                            <input type="color" id="widgetColorInput" oninput="updateActiveWidgetColor()" style="width:100%; height:30px;">
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="settings-section" id="sec-widgets">
            <div class="section-header">
                <div class="section-title">üñºÔ∏è Background & Widgets</div>
                <div class="section-arrow">‚ñº</div>
                <div class="window-controls">
                    <button class="min-btn" onclick="minimizeSection('sec-widgets')" title="Minimize">_</button>
                    <button class="dock-btn" onclick="dockSection('sec-widgets')" title="Dock">‚úï</button>
                </div>
            </div>
            <div class="section-content">
                <div style="display:flex; flex-direction:column; gap:5px; margin-top:5px;">
                    <div style="display:flex; gap:5px;">
                         <button class="btn-add-text" onclick="addTextWidget()">‚ûï Add Text Widget</button>
                    </div>
                    <div style="display:flex; gap:5px;">
                        <label class="file-label" for="widgetImageFile">‚ûï Add Image Widget</label>
                        <input type="file" id="widgetImageFile" accept="image/*">
                    </div>
                </div>
                <div class="toggle-row" onclick="document.getElementById('snapToggle').click()">
                    <label>üß≤ Snap to Grid</label> <input type="checkbox" id="snapToggle" checked onclick="event.stopPropagation()">
                </div>
                <button class="btn-delete" onclick="clearAllWidgets()">üóëÔ∏è Clear All Widgets</button>

                <div class="section-title" style="margin-top:10px; opacity:0.8;">Background Pattern</div>
                <div class="pattern-grid">
                    <div class="pattern-btn pat-none" onclick="selectPattern('none')" title="None"></div>
                    <div class="pattern-btn pat-dots" onclick="selectPattern('dots')" title="Dots"></div>
                    <div class="pattern-btn pat-stripes" onclick="selectPattern('stripes')" title="Stripes"></div>
                    <div class="pattern-btn pat-grid" onclick="selectPattern('grid')" title="Grid"></div>
                    <div class="pattern-btn pat-check" onclick="selectPattern('check')" title="Checkers"></div>
                    <div class="pattern-btn pat-zig" onclick="selectPattern('zig')" title="ZigZag"></div>
                </div>
                
                <div class="slider-group">
                    <label>Color</label>
                    <input type="color" id="patColor" value="#ffffff" oninput="updatePatternStyle()" style="height:35px; width:60px;">
                </div>
                <div class="slider-group">
                    <label>Opacity</label>
                    <input type="range" id="patOpacity" min="5" max="100" value="20" oninput="document.getElementById('patOpacityNum').value = this.value; updatePatternStyle()">
                    <input type="number" id="patOpacityNum" class="slider-val" value="20" min="5" max="100" oninput="document.getElementById('patOpacity').value = this.value; updatePatternStyle()">
                </div>

                <div style="display:flex; gap:5px; margin-top:5px;">
                      <label class="file-label" for="bgImageFile">Set BG Image</label>
                      <input type="file" id="bgImageFile" accept="image/*">
                </div>
                
                <div class="section-title" style="margin-top:10px; opacity:0.8;">Position</div>
                <div class="slider-group">
                    <label>Zoom</label>
                    <input type="range" id="bgZoom" min="10" max="200" value="30" oninput="document.getElementById('bgZoomNum').value = this.value; updateBgParams()">
                    <input type="number" id="bgZoomNum" class="slider-val" value="30" min="10" max="200" oninput="document.getElementById('bgZoom').value = this.value; updateBgParams()">
                </div>
                <div class="slider-group">
                    <label>Pan X</label>
                    <input type="range" id="bgPanX" min="0" max="100" value="50" oninput="document.getElementById('bgPanXNum').value = this.value; updateBgParams()">
                    <input type="number" id="bgPanXNum" class="slider-val" value="50" min="0" max="100" oninput="document.getElementById('bgPanX').value = this.value; updateBgParams()">
                </div>
                <div class="slider-group">
                    <label>Pan Y</label>
                    <input type="range" id="bgPanY" min="0" max="100" value="50" oninput="document.getElementById('bgPanYNum').value = this.value; updateBgParams()">
                    <input type="number" id="bgPanYNum" class="slider-val" value="50" min="0" max="100" oninput="document.getElementById('bgPanY').value = this.value; updateBgParams()">
                </div>
                <div class="toggle-row" onclick="document.getElementById('blendToggle').click()" style="margin-top:5px;">
                    <label>Blend Mode</label> <input type="checkbox" id="blendToggle" checked onchange="updatePatternStyle()" onclick="event.stopPropagation()">
                </div>
            </div>
        </div>

        <div class="settings-section" id="sec-layout">
            <div class="section-header">
                <div class="section-title">üìê Layout</div>
                <div class="section-arrow">‚ñº</div>
                <div class="window-controls">
                    <button class="min-btn" onclick="minimizeSection('sec-layout')" title="Minimize">_</button>
                    <button class="dock-btn" onclick="dockSection('sec-layout')" title="Dock">‚úï</button>
                </div>
            </div>
            <div class="section-content">
                <div class="pattern-grid" style="grid-template-columns: repeat(4, 1fr);">
                    <div class="layout-btn" onclick="changeLayout('standard')" title="Standard (Text Top)">
                        <div class="l-line" style="width:15px"></div>
                        <div class="l-box"></div>
                    </div>
                    <div class="layout-btn" onclick="changeLayout('inverted')" title="Inverted (Timer Top)">
                        <div class="l-box"></div>
                        <div class="l-line" style="width:15px"></div>
                    </div>
                    <div class="layout-btn" onclick="changeLayout('split')" title="Split (Text Left)">
                        <div style="display:flex; gap:2px; align-items:center;">
                            <div class="l-line" style="width:5px; height:10px;"></div>
                            <div class="l-box" style="width:10px; height:10px;"></div>
                        </div>
                    </div>
                    <div class="layout-btn" onclick="changeLayout('split-rev')" title="Split (Timer Left)">
                        <div style="display:flex; gap:2px; align-items:center;">
                            <div class="l-box" style="width:10px; height:10px;"></div>
                            <div class="l-line" style="width:5px; height:10px;"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="settings-section" id="sec-modes">
            <div class="section-header">
                <div class="section-title">üïπÔ∏è Modes</div>
                <div class="section-arrow">‚ñº</div>
                <div class="window-controls">
                    <button class="min-btn" onclick="minimizeSection('sec-modes')" title="Minimize">_</button>
                    <button class="dock-btn" onclick="dockSection('sec-modes')" title="Dock">‚úï</button>
                </div>
            </div>
            <div class="section-content">
                <div class="toggle-row" onclick="document.getElementById('cuberToggle').click()">
                    <label>üßä Cuber Mode</label> <input type="checkbox" id="cuberToggle" onchange="toggleCuberMode()" onclick="event.stopPropagation()">
                </div>
                
                <div class="toggle-row" onclick="document.getElementById('pomoToggle').click()" style="border-top:1px solid rgba(128,128,128,0.2); margin-top:5px; padding-top:5px;">
                    <label>üçÖ Pomodoro</label> <input type="checkbox" id="pomoToggle" onchange="togglePomoMode()" onclick="event.stopPropagation()">
                </div>
                
                <div id="pomoControls" style="display:none; margin-top:10px; background:var(--inner-panel-bg); padding:10px; border-radius:6px;">
                    <div class="slider-group">
                        <label style="width:70px">Work (m)</label>
                        <input type="number" id="pomoWork" value="25" min="1" max="120" onchange="updatePomoSettings()">
                    </div>
                    <div class="slider-group">
                        <label style="width:70px">Short (m)</label>
                        <input type="number" id="pomoShort" value="5" min="1" max="60" onchange="updatePomoSettings()">
                    </div>
                    <div class="slider-group">
                        <label style="width:70px">Long (m)</label>
                        <input type="number" id="pomoLong" value="15" min="1" max="120" onchange="updatePomoSettings()">
                    </div>
                </div>

                <div class="toggle-row" onclick="document.getElementById('clockToggle').click()" style="border-top:1px solid rgba(128,128,128,0.2); margin-top:5px; padding-top:5px;">
                    <label>üåé World Clock</label> <input type="checkbox" id="clockToggle" onchange="toggleClockMode()" onclick="event.stopPropagation()">
                </div>
                
                <div id="clockControls" style="display:none; margin-top:10px; padding:10px; background:var(--inner-panel-bg); border-radius:6px;">
                    <div class="section-title">Show Cities:</div>
                    <div style="display:grid; grid-template-columns: 1fr 1fr; gap:5px;">
                        <label><input type="checkbox" class="city-check" value="Manila" checked onchange="updateCitySelection()"> Manila</label>
                        <label><input type="checkbox" class="city-check" value="Tokyo" checked onchange="updateCitySelection()"> Tokyo</label>
                        <label><input type="checkbox" class="city-check" value="London" checked onchange="updateCitySelection()"> London</label>
                        <label><input type="checkbox" class="city-check" value="New York" checked onchange="updateCitySelection()"> NYC</label>
                        <label><input type="checkbox" class="city-check" value="Paris" onchange="updateCitySelection()"> Paris</label>
                        <label><input type="checkbox" class="city-check" value="Sydney" onchange="updateCitySelection()"> Sydney</label>
                        <label><input type="checkbox" class="city-check" value="Dubai" onchange="updateCitySelection()"> Dubai</label>
                        <label><input type="checkbox" class="city-check" value="Los Angeles" onchange="updateCitySelection()"> LA</label>
                    </div>
                </div>

                <div class="toggle-row" onclick="document.getElementById('lyricToggle').click()" style="border-top:1px solid rgba(128,128,128,0.2); margin-top:5px; padding-top:5px;">
                    <label>üéµ Lyric Sync</label> <input type="checkbox" id="lyricToggle" onchange="toggleLyricMode()" onclick="event.stopPropagation()">
                </div>
                
                <div id="lyricControls" style="display:none; margin-top:10px;">
                    <div style="margin-bottom:10px; display:flex; gap:5px; align-items:center;">
                        <div style="flex-grow:1;">
                             <label class="file-label" for="lyricAudioFile">üéµ Upload Song</label>
                             <input type="file" id="lyricAudioFile" accept="audio/*">
                        </div>
                        <button class="audio-btn btn-clear" onclick="clearLyricAudio()" style="width:auto; padding:0 10px;">‚úñ</button>
                    </div>
                    <div id="lyricAudioStatus" style="font-size:0.75rem; text-align:center; opacity:0.7; margin-top:2px;">No file chosen</div>

                    <div id="lyricAudioSettings" style="display:none; background:var(--inner-panel-bg); padding:8px; border-radius:6px; margin-bottom:10px; margin-top:10px;">
                        <div class="slider-group">
                            <label>Vol</label>
                            <input type="range" id="lyricVol" min="0" max="100" value="80" oninput="document.getElementById('lyricVolNum').value=this.value; updateLyricVolume(this.value)">
                            <input type="number" id="lyricVolNum" class="slider-val" value="80" min="0" max="100" oninput="document.getElementById('lyricVol').value=this.value; updateLyricVolume(this.value)">
                        </div>
                        <div class="audio-trimmer" style="display:flex; margin-top:0; background:none; padding:0;">
                            <div class="trim-info"><span>Start</span><span id="lyricTrimStartVal">0.0s</span></div>
                            <input type="range" id="lyricTrimStart" min="0" max="10" step="0.1" value="0" oninput="updateLyricTrim()">
                            <div class="trim-info"><span>Length</span><span id="lyricTrimDurVal">--</span></div>
                            <input type="range" id="lyricTrimDuration" min="1" max="10" step="1" value="300" oninput="updateLyricTrim()">
                        </div>
                    </div>

                    <textarea id="lyricInput" placeholder="Paste LRC format: [mm:ss.xx] Lyric"></textarea>
                    
                    <div class="slider-group" id="speedControlGroup" style="margin-top:5px;">
                        <label style="width:auto">Speed (s)</label>
                        <input type="range" id="lyricSpeed" min="1" max="10" value="3" oninput="document.getElementById('lyricSpeedNum').value = this.value">
                        <input type="number" id="lyricSpeedNum" class="slider-val" value="3" min="1" max="10" oninput="document.getElementById('lyricSpeed').value = this.value">
                    </div>
                    <div id="lrcStatus" style="font-size:0.75rem; opacity:0.7; margin-top:5px; display:none; color: #2ecc71;">
                        ‚úì LRC Timestamps Detected
                    </div>
                </div>
            </div>
        </div>

        <div class="settings-section" id="sec-appearance">
            <div class="section-header">
                <div class="section-title">üé® Appearance</div>
                <div class="section-arrow">‚ñº</div>
                <div class="window-controls">
                    <button class="min-btn" onclick="minimizeSection('sec-appearance')" title="Minimize">_</button>
                    <button class="dock-btn" onclick="dockSection('sec-appearance')" title="Dock">‚úï</button>
                </div>
            </div>
            <div class="section-content">
                <div style="margin-bottom:10px;">
                    <label class="file-label" for="customFontFile" style="margin-bottom:5px;">üî§ Upload Custom Font</label>
                    <input type="file" id="customFontFile" accept=".ttf, .otf, .woff, .woff2">
                    
                    <select id="fontSelect" onchange="changeFont()">
                        <option value="'Inter', sans-serif">Modern (Inter)</option>
                        <option value="'Roboto', sans-serif">Standard (Roboto)</option>
                        <option value="'Orbitron', sans-serif">Digital (Orbitron)</option>
                        <option value="'JetBrains Mono', monospace">Coding (JetBrains)</option>
                        <option value="'Press Start 2P', cursive">Retro (Pixel)</option>
                        <option value="'Bangers', cursive">Impact (Bangers)</option>
                        <option value="'Lobster', cursive">Fun (Lobster)</option>
                        <option value="'Oswald', sans-serif">Bold (Oswald)</option>
                        <option value="'Playfair Display', serif">Elegant (Playfair)</option>
                        <option value="'Pacifico', cursive">Handwriting (Pacifico)</option>
                        <option value="'Caveat', cursive">Marker (Caveat)</option>
                    </select>
                </div>
                <div class="toggle-row" onclick="document.getElementById('titleToggle').click()">
                    <label>Show Message</label> <input type="checkbox" id="titleToggle" checked onchange="toggleTitleVisibility()" onclick="event.stopPropagation()">
                </div>
                <div class="toggle-row" onclick="document.getElementById('msToggle').click()">
                    <label>Show MS</label> <input type="checkbox" id="msToggle" onchange="toggleMsVisibility()" onclick="event.stopPropagation()">
                </div>
            </div>
        </div>

        <div class="settings-section" id="sec-audio">
            <div class="section-header">
                <div class="section-title">üîä Audio</div>
                <div class="section-arrow">‚ñº</div>
                <div class="window-controls">
                    <button class="min-btn" onclick="minimizeSection('sec-audio')" title="Minimize">_</button>
                    <button class="dock-btn" onclick="dockSection('sec-audio')" title="Dock">‚úï</button>
                </div>
            </div>
            <div class="section-content">
                <div class="slider-group">
                    <label>Click</label>
                    <input type="range" id="volClickRange" min="0" max="100" value="30" oninput="document.getElementById('volClickNum').value=this.value; volClick = this.value/100; playClick()">
                    <input type="number" id="volClickNum" class="slider-val" value="30" min="0" max="100" oninput="document.getElementById('volClickRange').value=this.value; volClick = this.value/100; playClick()">
                </div>
                <div class="slider-group">
                    <label>Tick</label>
                    <input type="range" id="volTickRange" min="0" max="100" value="10" oninput="document.getElementById('volTickNum').value=this.value; volTick = this.value/100; playTick()">
                    <input type="number" id="volTickNum" class="slider-val" value="10" min="0" max="100" oninput="document.getElementById('volTickRange').value=this.value; volTick = this.value/100; playTick()">
                </div>
                <div class="slider-group">
                    <label>Alarm</label>
                    <input type="range" id="volAlarmRange" min="0" max="100" value="50" oninput="document.getElementById('volAlarmNum').value=this.value; volAlarm = this.value/100;">
                    <input type="number" id="volAlarmNum" class="slider-val" value="50" min="0" max="100" oninput="document.getElementById('volAlarmRange').value=this.value; volAlarm = this.value/100;">
                </div>
                
                <div style="margin-top:10px;">
                    <label class="file-label" for="audioFile">Upload Custom Alarm</label>
                    <input type="file" id="audioFile" accept="audio/*">
                    
                    <div class="audio-actions">
                        <button class="audio-btn btn-test" onclick="playCustomPreview()">‚ñ∂ Test</button>
                        <button class="audio-btn btn-clear" onclick="clearCustomAudio()">‚úñ Remove</button>
                    </div>

                    <div class="audio-trimmer" id="audioTrimmer">
                        <div class="trim-info"><span>Start</span><span id="trimStartVal">0.0s</span></div>
                        <input type="range" id="trimStart" min="0" max="10" step="0.1" value="0">
                        <div class="trim-info"><span>Length</span><span id="trimDurVal">1.0s</span></div>
                        <input type="range" id="trimDuration" min="0.1" max="10" step="0.1" value="5">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<div class="controls">
    <input type="color" id="colorPicker" value="#3498db" title="Change Theme">
    <button class="main-btn" id="toggleBtn" onmousedown="playClick()" onclick="toggleTimer()">Start</button>
    <button class="main-btn" onmousedown="playClick()" onclick="resetTimer()">Reset</button>
    
    <div id="qaContainer" style="display:contents;"></div>
    <div id="minimizedWindows" style="display:contents;"></div>

    <button class="main-btn" onmousedown="playClick()" onclick="toggleFullScreen()" title="Fullscreen">‚õ∂</button>
    <button class="main-btn" onmousedown="playClick()" onclick="toggleSettings()" title="Settings">‚öôÔ∏è</button>
</div>

<script>
    // --- GLOBAL VARIABLES ---
    let timeLeft = 300000, originalTime = 300000;
    let timerInterval, isRunning = false, isEditing = false;
    let isCuberMode = false, holdTimeout, isArmed = false;
    let timerEndTime = 0, timerStartTime = 0, lastSecond = 0;
    let currentBgMode = 'none', currentPatternType = 'none';
    let currentBgDataURL = ''; 
    let volClick = 0.3, volTick = 0.1, volAlarm = 0.5, customAlarmBuffer = null;
    let solveHistory = []; 
    let customFonts = []; 
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    const audioCtx = new AudioContext();

    // LYRIC VARS
    let isLyricMode = false;
    let lyricLines = []; 
    let isLrcFormat = false;
    let lyricIndex = 0;
    let lyricInterval; 
    let lyricAudio = null; 
    let lyricStartTime = 0;
    let lyricDuration = 300; 

    // POMODORO VARS
    let isPomoMode = false;
    let pomoState = 'work'; 
    let pomoWorkTime = 25;
    let pomoShortTime = 5;
    let pomoLongTime = 15;

    // WORLD CLOCK VARS
    let isClockMode = false;
    let clockInterval;
    let selectedCities = ["Manila", "Tokyo", "London", "New York"];
    const cityTimeZones = {
        "Manila": "Asia/Manila",
        "Tokyo": "Asia/Tokyo",
        "London": "Europe/London",
        "New York": "America/New_York",
        "Paris": "Europe/Paris",
        "Sydney": "Australia/Sydney",
        "Dubai": "Asia/Dubai",
        "Los Angeles": "America/Los_Angeles"
    };

    // ALARM VARS
    let alarmTimeout, alarmInterval, activeAlarmSource;
    let audioDuration = 0;

    // WIDGET VARS
    let widgets = []; 
    let activeWidgetId = null;
    let isDraggingWidget = false, isResizingWidget = false, isRotatingWidget = false;
    let startX, startY, startWidth, startHeight, startRotation, startCenterX, startCenterY;
    let startFontSize = 0, startDist = 0;
    
    // SETTINGS DRAG VARS
    let draggedSection = null;
    let sectionDragOffsetX = 0;
    let sectionDragOffsetY = 0;
    let dragPlaceholder = null;

    // Elements
    const mainContainer = document.getElementById('mainContainer');
    const timerDisplay = document.getElementById('timer');
    const mainTitle = document.getElementById('mainTitle');
    const scrambleDisplay = document.getElementById('scrambleDisplay');
    const statsDisplay = document.getElementById('statsDisplay'); 
    const settingsPanel = document.getElementById('settingsPanel');
    const panelHeader = document.getElementById('panelHeader');
    const customAlert = document.getElementById('customAlert');
    const alertMsg = document.getElementById('alertMsg');
    const pomoStatus = document.getElementById('pomoStatus');
    const widgetLayer = document.getElementById('widgetLayer');
    const guideV = document.getElementById('guide-v');
    const guideH = document.getElementById('guide-h');
    const snapToggle = document.getElementById('snapToggle');
    const layersList = document.getElementById('layersList');
    const minimizedContainer = document.getElementById('minimizedWindows');

    const worldClockContainer = document.getElementById('worldClockContainer');
    const localTimeDisplay = document.getElementById('localTime');
    const localDateDisplay = document.getElementById('localDate');
    const citiesGrid = document.getElementById('citiesGrid');
    
    const qaContainer = document.getElementById('qaContainer');

    // Inputs
    const fontSelect = document.getElementById('fontSelect');
    const sliderZoom = document.getElementById('bgZoom');
    const sliderPanX = document.getElementById('bgPanX');
    const sliderPanY = document.getElementById('bgPanY');
    const patColorInput = document.getElementById('patColor');
    const patOpacityInput = document.getElementById('patOpacity');
    const blendToggle = document.getElementById('blendToggle');

    const cuberToggle = document.getElementById('cuberToggle');
    const pomoToggle = document.getElementById('pomoToggle');
    const clockToggle = document.getElementById('clockToggle');

    const colorPicker = document.getElementById('colorPicker');

    // Pomo Inputs
    const pomoControls = document.getElementById('pomoControls');
    const pomoWorkInput = document.getElementById('pomoWork');
    const pomoShortInput = document.getElementById('pomoShort');
    const pomoLongInput = document.getElementById('pomoLong');

    // Clock Inputs
    const clockControls = document.getElementById('clockControls');

    // Lyric Inputs
    const lyricControls = document.getElementById('lyricControls');
    const lyricInput = document.getElementById('lyricInput');
    const lyricSpeedInput = document.getElementById('lyricSpeed');
    const speedControlGroup = document.getElementById('speedControlGroup');
    const lrcStatus = document.getElementById('lrcStatus');
    const lyricAudioInput = document.getElementById('lyricAudioFile');
    const lyricAudioStatus = document.getElementById('lyricAudioStatus');
    const lyricAudioSettings = document.getElementById('lyricAudioSettings');
    const lyricTrimStartInput = document.getElementById('lyricTrimStart');
    const lyricTrimDurInput = document.getElementById('lyricTrimDuration');
    const lyricTrimStartVal = document.getElementById('lyricTrimStartVal');
    const lyricTrimDurVal = document.getElementById('lyricTrimDurVal');

    // Trim Inputs
    const trimmerDiv = document.getElementById('audioTrimmer');
    const trimStartInput = document.getElementById('trimStart');
    const trimDurInput = document.getElementById('trimDuration');
    const trimStartVal = document.getElementById('trimStartVal');
    const trimDurVal = document.getElementById('trimDurVal');

    // Widget Settings Inputs
    const activeWidgetSettings = document.getElementById('activeWidgetSettings');
    const widgetTextInput = document.getElementById('widgetTextInput');
    const widgetSizeInput = document.getElementById('widgetSizeInput');
    const widgetColorInput = document.getElementById('widgetColorInput');

    function init() {
        updateColors(colorPicker.value);
        // Add System Layer
        widgets.push({ id: 'system-ui', type: 'system', name: '‚è±Ô∏è Timer & Title', fixed: true, locked: false });

        if(cuberToggle.checked) { isCuberMode = true; timerDisplay.setAttribute('contenteditable', 'false'); scrambleDisplay.style.display = 'block'; generateScramble(); }
        updateLayout(); updateDisplay();
        renderLayerList();
        updateLayerZIndices();
        updateQuickAccess(); // Init toolbar
        setupSectionDrag();
    }

    /* --- DETACHABLE SECTIONS LOGIC --- */
    function setupSectionDrag() {
        document.querySelectorAll('.section-header').forEach(header => {
            header.addEventListener('mousedown', startSectionDrag);
            // Collapse toggle logic
            header.addEventListener('click', (e) => {
                if(e.target.closest('.dock-btn') || e.target.closest('.min-btn')) return; 
                const section = header.parentElement;
                if (!section.classList.contains('detached') && !draggedSection) {
                    section.classList.toggle('collapsed');
                }
            });
        });
    }

    function startSectionDrag(e) {
        if(e.target.closest('.dock-btn') || e.target.closest('.min-btn')) return;
        const section = e.target.closest('.settings-section');
        if(!section) return;
        if(e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT' || e.target.tagName === 'BUTTON' || e.target.tagName === 'TEXTAREA') return;

        const startX = e.clientX;
        const startY = e.clientY;
        
        const onMouseMove = (ev) => {
            if (Math.abs(ev.clientX - startX) > 5 || Math.abs(ev.clientY - startY) > 5) {
                document.removeEventListener('mousemove', onMouseMove);
                document.removeEventListener('mouseup', onMouseUp);
                initiateSectionDrag(section, ev, startX, startY);
            }
        };
        
        const onMouseUp = () => {
            document.removeEventListener('mousemove', onMouseMove);
            document.removeEventListener('mouseup', onMouseUp);
        };
        
        document.addEventListener('mousemove', onMouseMove);
        document.addEventListener('mouseup', onMouseUp);
    }

    function initiateSectionDrag(section, e, startX, startY) {
        e.preventDefault();
        draggedSection = section;
        const rect = section.getBoundingClientRect();
        
        sectionDragOffsetX = e.clientX - rect.left;
        sectionDragOffsetY = e.clientY - rect.top;

        if (!dragPlaceholder) {
            dragPlaceholder = document.createElement('div');
            dragPlaceholder.className = 'section-placeholder';
        }
        dragPlaceholder.style.height = rect.height + 'px';
        
        if (!section.classList.contains('detached')) {
            section.parentNode.insertBefore(dragPlaceholder, section);
            section.style.width = rect.width + 'px';
        }

        document.body.appendChild(section);
        section.classList.add('detached');
        section.classList.add('dragging'); 
        section.classList.remove('collapsed'); 
        
        section.style.left = (e.clientX - sectionDragOffsetX) + 'px';
        section.style.top = (e.clientY - sectionDragOffsetY) + 'px';

        document.addEventListener('mousemove', dragSectionMove);
        document.addEventListener('mouseup', dragSectionEnd);
    }

    function dragSectionMove(e) {
        if (!draggedSection) return;
        e.preventDefault();
        
        draggedSection.style.left = (e.clientX - sectionDragOffsetX) + 'px';
        draggedSection.style.top = (e.clientY - sectionDragOffsetY) + 'px';

        const panelContent = document.getElementById('panelContent');
        const panelRect = panelContent.getBoundingClientRect();
        
        if (e.clientX >= panelRect.left && e.clientX <= panelRect.right &&
            e.clientY >= panelRect.top && e.clientY <= panelRect.bottom &&
            !document.getElementById('settingsPanel').classList.contains('hidden')) {
            
            const afterElement = getDragAfterElement(panelContent, e.clientY);
            
            if (!dragPlaceholder.parentNode || dragPlaceholder.parentNode !== panelContent) {
                panelContent.appendChild(dragPlaceholder);
            }
            
            if (afterElement == null) {
                panelContent.appendChild(dragPlaceholder);
            } else {
                panelContent.insertBefore(dragPlaceholder, afterElement);
            }
        } else {
            if (dragPlaceholder && dragPlaceholder.parentNode) {
                dragPlaceholder.parentNode.removeChild(dragPlaceholder);
            }
        }
    }

    function getDragAfterElement(container, y) {
        const draggableElements = [...container.querySelectorAll('.settings-section:not(.dragging):not(.detached)')];

        return draggableElements.reduce((closest, child) => {
            const box = child.getBoundingClientRect();
            const offset = y - box.top - box.height / 2;
            if (offset < 0 && offset > closest.offset) {
                return { offset: offset, element: child };
            } else {
                return closest;
            }
        }, { offset: Number.NEGATIVE_INFINITY }).element;
    }

    function dragSectionEnd() {
        if (!draggedSection) return;
        
        draggedSection.classList.remove('dragging');
        
        if (dragPlaceholder && dragPlaceholder.parentNode) {
            draggedSection.classList.remove('detached');
            draggedSection.style.position = '';
            draggedSection.style.width = '';
            draggedSection.style.left = '';
            draggedSection.style.top = '';
            draggedSection.style.zIndex = '';
            
            dragPlaceholder.parentNode.insertBefore(draggedSection, dragPlaceholder);
            dragPlaceholder.remove();
        } 
        
        if (dragPlaceholder && dragPlaceholder.parentNode) dragPlaceholder.remove();
        draggedSection = null;
        dragPlaceholder = null;
        
        document.removeEventListener('mousemove', dragSectionMove);
        document.removeEventListener('mouseup', dragSectionEnd);
    }

    function dockSection(id) {
        const section = document.getElementById(id);
        const panelContent = document.getElementById('panelContent');
        
        section.classList.remove('detached');
        section.classList.remove('minimized');
        section.style.display = '';
        section.style.left = '';
        section.style.top = '';
        section.style.position = '';
        section.style.zIndex = '';
        section.style.width = ''; 
        
        const btn = document.getElementById('min-btn-' + id);
        if(btn) btn.remove();

        panelContent.appendChild(section);
    }

    function minimizeSection(id) {
        const section = document.getElementById(id);
        section.classList.add('minimized');
        
        const btn = document.createElement('button');
        btn.className = 'main-btn';
        btn.id = 'min-btn-' + id;
        
        const title = section.querySelector('.section-title').innerText.trim();
        const icon = title.split(' ')[0] || title;

        btn.innerText = icon;
        btn.title = "Restore " + title;
        btn.onclick = () => {
            section.classList.remove('minimized');
            btn.remove();
        };
        
        minimizedContainer.appendChild(btn);
    }


    /* --- QUICK ACCESS TOOLBAR --- */
    function updateQuickAccess() {
        const checkboxes = document.querySelectorAll('.qa-check');
        qaContainer.innerHTML = '';
        
        checkboxes.forEach(cb => {
            if(cb.checked) {
                const btn = document.createElement('button');
                btn.className = 'main-btn';
                btn.onmousedown = playClick;
                
                if(cb.value === 'cuber') {
                    btn.innerText = 'üßä';
                    btn.title = 'Toggle Cuber Mode';
                    btn.onclick = () => { document.getElementById('cuberToggle').click(); };
                    if(cuberToggle.checked) btn.style.background = '#2ecc71';
                } else if(cb.value === 'pomo') {
                    btn.innerText = 'üçÖ';
                    btn.title = 'Toggle Pomodoro';
                    btn.onclick = () => { document.getElementById('pomoToggle').click(); };
                    if(pomoToggle.checked) btn.style.background = '#e74c3c';
                } else if(cb.value === 'lyric') {
                    btn.innerText = 'üéµ';
                    btn.title = 'Toggle Lyrics';
                    btn.onclick = () => { document.getElementById('lyricToggle').click(); };
                    if(document.getElementById('lyricToggle').checked) btn.style.background = '#9b59b6';
                } else if(cb.value === 'clock') {
                    btn.innerText = 'üåé';
                    btn.title = 'Toggle World Clock';
                    btn.onclick = () => { document.getElementById('clockToggle').click(); };
                    if(clockToggle.checked) btn.style.background = '#f1c40f';
                } else if(cb.value === 'github') {
                    btn.innerHTML = '<img src="https://cdn.simpleicons.org/github/white" style="width:16px;height:16px;vertical-align:middle;">';
                    btn.title = 'Open GitHub';
                    btn.onclick = () => { window.open('https://github.com/CircleSideisCOOL/tenshon-timer', '_blank'); };
                    btn.style.background = '#333';
                    btn.style.color = '#fff';
                    btn.style.display = 'flex';
                    btn.style.alignItems = 'center';
                    btn.style.justifyContent = 'center';
                } else if(cb.value === 'kofi') {
                    btn.innerHTML = '<img src="https://cdn.simpleicons.org/kofi/white" style="width:16px;height:16px;vertical-align:middle;">';
                    btn.title = 'Support on Ko-fi';
                    btn.onclick = () => { window.open('https://ko-fi.com/circle_side', '_blank'); };
                    btn.style.background = '#29abe0';
                    btn.style.color = '#fff';
                    btn.style.display = 'flex';
                    btn.style.alignItems = 'center';
                    btn.style.justifyContent = 'center';
                }
                
                qaContainer.appendChild(btn);
            }
        });
    }

    const originalToggleCuber = toggleCuberMode;
    toggleCuberMode = function() { originalToggleCuber(); updateQuickAccess(); };
    
    const originalTogglePomo = togglePomoMode;
    togglePomoMode = function() { originalTogglePomo(); updateQuickAccess(); };
    
    const originalToggleClock = toggleClockMode;
    toggleClockMode = function() { originalToggleClock(); updateQuickAccess(); };
    
    const originalToggleLyric = toggleLyricMode;
    toggleLyricMode = function() { originalToggleLyric(); updateQuickAccess(); };


/* --- CUSTOM FONT SYSTEM --- */
document.getElementById('customFontFile').addEventListener('change', function(e) {
    const file = e.target.files[0];
    if(!file) return;

    const reader = new FileReader();
    reader.onload = function(ev) {
        const fontName = file.name.split('.')[0];
        const fontData = ev.target.result;
        addCustomFont(fontName, fontData);
    };
    reader.readAsDataURL(file);
    e.target.value = '';
});

async function addCustomFont(name, data, selectIt = true) {
    try {
        const fontFace = new FontFace(name, `url(${data})`);
        await fontFace.load();
        document.fonts.add(fontFace);

        if (!customFonts.some(f => f.name === name)) {
            customFonts.push({ name: name, src: data });

            const option = document.createElement('option');
            option.value = name;
            option.innerText = name + " (Custom)";
            fontSelect.appendChild(option);
        }

        if(selectIt) {
            fontSelect.value = name;
            changeFont();
            showAlert(`Font "${name}" Loaded!`);
        }
    } catch(err) {
        console.error(err);
        showAlert("Failed to load font.");
    }
}

/* --- SAVE & LOAD SYSTEM --- */
function saveConfig() {
    let layout = 'standard';
    if (document.body.classList.contains('layout-inverted')) layout = 'inverted';
    if (document.body.classList.contains('layout-split')) layout = 'split';
    if (document.body.classList.contains('layout-split-rev')) layout = 'split-rev';

    const qaItems = [];
    document.querySelectorAll('.qa-check').forEach(cb => {
        if(cb.checked) qaItems.push(cb.value);
    });

    const sections = ['sec-data', 'sec-quick', 'sec-layers', 'sec-appearance', 'sec-layout', 'sec-widgets', 'sec-modes', 'sec-audio'];
    const windowStates = {};
    sections.forEach(id => {
        const el = document.getElementById(id);
        if(el) {
            windowStates[id] = {
                detached: el.classList.contains('detached'),
                minimized: el.classList.contains('minimized'),
                collapsed: el.classList.contains('collapsed'),
                left: el.style.left,
                top: el.style.top,
                width: el.style.width
            };
        }
    });

    const config = {
        version: 1,
        themeColor: colorPicker.value,
        font: fontSelect.value,
        customFonts: customFonts, 
        layout: layout,
        qaItems: qaItems, 
        windowStates: windowStates, 
        bg: {
            mode: currentBgMode,
            pattern: currentPatternType,
            image: currentBgMode === 'image' ? document.body.style.backgroundImage : '',
            color: patColorInput.value,
            opacity: patOpacityInput.value,
            zoom: sliderZoom.value,
            panX: sliderPanX.value,
            panY: sliderPanY.value,
            blend: blendToggle.checked
        },
        modes: {
            cuber: isCuberMode,
            pomo: isPomoMode,
            clock: isClockMode,
            lyric: isLyricMode
        },
        pomoSettings: { work: pomoWorkTime, short: pomoShortTime, long: pomoLongTime },
        clockCities: selectedCities,
        audio: { click: volClick, tick: volTick, alarm: volAlarm },
        widgets: widgets.map(w => {
            if (w.type === 'system') {
                return { type: 'system', locked: w.locked };
            }
            return {
                type: w.type,
                name: w.name,
                src: w.src,
                text: w.text,
                color: w.color,
                fontSize: w.fontSize,
                locked: w.locked,
                left: w.el.style.left,
                top: w.el.style.top,
                width: w.el.style.width,
                rotation: w.el.dataset.rotation
            };
        }),
        lyrics: lyricInput.value,
        mainTitleText: mainTitle.innerText
    };

    const blob = new Blob([JSON.stringify(config)], {type: "application/json"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = "tenshon-config.json";
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    showAlert("Config Saved!");
}

function loadConfig(input) {
    const file = input.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = async function(e) {
        try {
            const config = JSON.parse(e.target.result);
            await applyConfig(config);
            showAlert("Config Loaded Successfully!");
        } catch(err) {
            console.error(err);
            showAlert("Error loading config file.");
        }
    };
    reader.readAsText(file);
    input.value = ''; 
}

async function applyConfig(config) {
    colorPicker.value = config.themeColor;
    updateColors(config.themeColor);

    if(config.customFonts) {
        for(const f of config.customFonts) {
            if (![...fontSelect.options].some(o => o.value === f.name)) {
                await addCustomFont(f.name, f.src, false);
            }
        }
    }

    fontSelect.value = config.font;
    changeFont();
    changeLayout(config.layout);

    if(config.qaItems) {
        document.querySelectorAll('.qa-check').forEach(cb => {
            cb.checked = config.qaItems.includes(cb.value);
        });
        updateQuickAccess();
    }
    
    if (config.windowStates) {
        Object.keys(config.windowStates).forEach(id => {
            const state = config.windowStates[id];
            const el = document.getElementById(id);
            if(!el) return;

            dockSection(id); 
            
            if(state.collapsed) el.classList.add('collapsed');
            else el.classList.remove('collapsed');

            if(state.detached) {
                document.body.appendChild(el);
                el.classList.add('detached');
                el.style.left = state.left;
                el.style.top = state.top;
                el.style.width = state.width;
                el.style.position = 'fixed'; 
                
                if(state.minimized) {
                    minimizeSection(id);
                }
            }
        });
    }

    currentBgMode = config.bg.mode;
    currentPatternType = config.bg.pattern;
    patColorInput.value = config.bg.color;
    patOpacityInput.value = config.bg.opacity;
    sliderZoom.value = config.bg.zoom;
    sliderPanX.value = config.bg.panX;
    sliderPanY.value = config.bg.panY;
    blendToggle.checked = config.bg.blend;

    document.getElementById('bgZoomNum').value = config.bg.zoom;
    document.getElementById('bgPanXNum').value = config.bg.panX;
    document.getElementById('bgPanYNum').value = config.bg.panY;
    document.getElementById('patOpacityNum').value = config.bg.opacity;

    if (currentBgMode === 'image') {
        document.body.classList.add('custom-image-mode');
        document.body.style.backgroundImage = config.bg.image;
    } else {
        document.body.classList.remove('custom-image-mode');
        updatePatternStyle();
    }
    updateBgParams();

    if (isCuberMode) { cuberToggle.checked = false; toggleCuberMode(); }
    if (isPomoMode) { pomoToggle.checked = false; togglePomoMode(); }
    if (isClockMode) { clockToggle.checked = false; toggleClockMode(); }
    if (isLyricMode) { document.getElementById('lyricToggle').checked = false; toggleLyricMode(); }

    if (config.modes.cuber) { cuberToggle.checked = true; toggleCuberMode(); }
    if (config.modes.pomo) { 
        pomoToggle.checked = true; 
        pomoWorkInput.value = config.pomoSettings.work;
        pomoShortInput.value = config.pomoSettings.short;
        pomoLongInput.value = config.pomoSettings.long;
        togglePomoMode();
    }
    if (config.modes.clock) { 
        clockToggle.checked = true; 
        selectedCities = config.clockCities || selectedCities;
        document.querySelectorAll('.city-check').forEach(cb => cb.checked = selectedCities.includes(cb.value));
        toggleClockMode(); 
    }

    lyricInput.value = config.lyrics || '';
    if (config.modes.lyric) { 
        document.getElementById('lyricToggle').checked = true; 
        toggleLyricMode();
    }

    if (!config.modes.lyric && config.mainTitleText) {
        mainTitle.innerText = config.mainTitleText;
    }

    volClick = config.audio.click; document.getElementById('volClickRange').value = volClick*100;
    volTick = config.audio.tick; document.getElementById('volTickRange').value = volTick*100;
    volAlarm = config.audio.alarm; document.getElementById('volAlarmRange').value = volAlarm*100;

    const systemEl = document.getElementById('mainContainer');
    widgetLayer.innerHTML = ''; 
    widgets = []; 

    config.widgets.forEach(w => {
        if (w.type === 'system') {
            widgets.push({ id: 'system-ui', type: 'system', name: '‚è±Ô∏è Timer & Title', fixed: true, locked: w.locked });
            if(w.locked) systemEl.classList.add('locked'); else systemEl.classList.remove('locked');
        } else {
            restoreWidget(w);
        }
    });

    updateLayerZIndices();
    renderLayerList();
    playClick();
}

function restoreWidget(data) {
    const id = Date.now().toString() + Math.random().toString(16).slice(2);
    const widget = document.createElement('div');
    widget.className = 'widget';
    widget.id = 'w-' + id;

    widget.style.left = data.left;
    widget.style.top = data.top;
    widget.dataset.rotation = data.rotation;
    widget.style.transform = `translate(-50%, -50%) rotate(${data.rotation}deg)`;
    
    // Restore width for image, use text content for text size
    if (data.type === 'image') {
        widget.style.width = data.width;
    } else if (data.type === 'text') {
        widget.style.width = 'max-content'; // Allow text to scale
    }

    if(data.locked) widget.classList.add('locked');

    let innerHTML = '';
    if (data.type === 'image') {
        innerHTML = `<img src="${data.src}" draggable="false">`;
    } else if (data.type === 'text') {
        innerHTML = `<div class="widget-text-content" style="color: ${data.color}; font-size: ${data.fontSize}px;">${data.text}</div>`;
    }

    innerHTML += `
        <div class="widget-controls">
            <div class="w-handle w-delete">‚úï</div>
            <div class="w-handle w-rotate"></div>
            <div class="w-handle w-resize"></div>
        </div>
    `;
    widget.innerHTML = innerHTML;

    widget.ondblclick = (e) => {
        e.stopPropagation(); 
        if(data.type === 'text') enterTextEditMode(id);
    };

    widgetLayer.appendChild(widget);

    widgets.push({ 
        id: id, 
        el: widget, 
        type: data.type, 
        name: data.name, 
        src: data.src, 
        text: data.text, 
        color: data.color, 
        fontSize: data.fontSize, 
        locked: data.locked 
    });
}

/* --- WIDGET SYSTEM --- */
document.getElementById('widgetImageFile').addEventListener('change', function(e) {
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = function(ev) {
        createWidget('image', ev.target.result, file.name);
        showAlert("Image Added!<br>Check Layers Tab.");
        playClick();
    };
    reader.readAsDataURL(file);
    e.target.value = ''; 
});

function addTextWidget() {
    createWidget('text', 'New Text', 'Text Widget');
    showAlert("Text Added!");
    playClick();
}

function createWidget(type, content, name) {
    const id = Date.now().toString(); 
    const widget = document.createElement('div');
    widget.className = 'widget';
    widget.id = 'w-' + id;
    
    // CENTER FIX: Apply offsets to left/top instead of transform
    const offsetX = (Math.random() - 0.5) * 100;
    const offsetY = (Math.random() - 0.5) * 100;
    
    widget.style.left = `calc(50% + ${offsetX}px)`;
    widget.style.top = `calc(50% + ${offsetY}px)`;
    widget.dataset.rotation = '0';
    widget.style.transform = `translate(-50%, -50%) rotate(0deg)`;

    let innerHTML = '';
    let props = { type: type, name: name || 'Widget', locked: false };

    if (type === 'image') {
        widget.style.width = '200px';
        innerHTML = `<img src="${content}" draggable="false">`;
        props.src = content;
    } else if (type === 'text') {
        widget.style.width = 'max-content'; 
        widget.style.minWidth = '50px';
        innerHTML = `<div class="widget-text-content" style="color: #ffffff; font-size: 50px;">${content}</div>`;
        props.text = content;
        props.color = '#ffffff';
        props.fontSize = 50;
    }

    innerHTML += `
        <div class="widget-controls">
            <div class="w-handle w-delete">‚úï</div>
            <div class="w-handle w-rotate"></div>
            <div class="w-handle w-resize"></div>
        </div>
    `;
    widget.innerHTML = innerHTML;

    widget.ondblclick = (e) => {
        e.stopPropagation(); 
        if(type === 'text') enterTextEditMode(id);
    };

    widgetLayer.appendChild(widget);

    widgets.push({ id: id, el: widget, ...props });

    updateLayerZIndices();
    renderLayerList();
    activateWidgetId(id);
}

function enterTextEditMode(id) {
    const wObj = widgets.find(w => w.id === id);
    if (!wObj || wObj.type !== 'text' || wObj.locked) return;

    const textEl = wObj.el.querySelector('.widget-text-content');
    if (!textEl) return;

    textEl.contentEditable = "true";
    textEl.focus();

    const range = document.createRange();
    range.selectNodeContents(textEl);
    const sel = window.getSelection();
    sel.removeAllRanges();
    sel.addRange(range);

    textEl.onblur = function() {
        this.contentEditable = "false";
        wObj.text = this.innerText; 
        if(activeWidgetId === id) widgetTextInput.value = wObj.text; 
        window.getSelection().removeAllRanges();
    };

    textEl.onkeydown = function(e) {
        e.stopPropagation(); 
    };

    textEl.oninput = function() {
        wObj.text = this.innerText; 
    };
}

function updateLayerZIndices() {
    widgets.forEach((w, index) => {
        if (w.type === 'system') {
            mainContainer.style.zIndex = 10 + index;
        } else {
            w.el.style.zIndex = 10 + index; 
        }
    });
}

function renderLayerList() {
    layersList.innerHTML = '';
    if (widgets.length === 0) {
        layersList.innerHTML = '<div class="no-layers">No widgets added</div>';
        activeWidgetSettings.style.display = 'none';
        return;
    }

    const reversed = [...widgets].reverse();

    reversed.forEach((w, revIndex) => {
        const realIndex = widgets.length - 1 - revIndex; 

        const item = document.createElement('div');
        item.className = 'layer-item';
        if(w.id === activeWidgetId) item.classList.add('active-layer');
        if(w.type === 'system') item.classList.add('system-layer');

        let thumbHTML = '';
        if(w.type === 'image') {
            thumbHTML = `<img src="${w.src}" class="layer-thumb">`;
        } else if (w.type === 'text') {
            thumbHTML = `<div class="layer-icon-text">T</div>`;
        } else if (w.type === 'system') {
            thumbHTML = `<div class="layer-icon-text">‚è±Ô∏è</div>`;
        }

        const lockIcon = w.locked ? 'üîí' : 'üîì';
        const lockClass = w.locked ? 'locked' : '';

        let controlsHTML = `
            <button class="layer-btn ${lockClass}" onclick="toggleWidgetLock('${w.id}')" title="Lock/Unlock">${lockIcon}</button>
        `;

        if(!w.locked) {
            controlsHTML += `
                <button class="layer-btn" onclick="moveLayer(${realIndex}, 1)" title="Bring Forward">‚Üë</button>
                <button class="layer-btn" onclick="moveLayer(${realIndex}, -1)" title="Send Backward">‚Üì</button>
            `;

            if(w.type !== 'system') {
                controlsHTML += `<button class="layer-btn btn-del-layer" onclick="deleteWidgetById('${w.id}')" title="Delete">‚úï</button>`;
            }
        }

        item.innerHTML = `
            ${thumbHTML}
            <div class="layer-name">${w.name}</div>
            <div class="layer-controls">
                ${controlsHTML}
            </div>
        `;

        item.addEventListener('click', (e) => {
            if(e.target.closest('.layer-btn')) return; 
            if(w.type !== 'system' && !w.locked) activateWidgetId(w.id);
        });

        layersList.appendChild(item);
    });
}

function toggleWidgetLock(id) {
    const w = widgets.find(x => x.id === id);
    if(!w) return;
    w.locked = !w.locked;

    if (w.type === 'system') {
        const container = document.getElementById('mainContainer');
        if(w.locked) container.classList.add('locked');
        else container.classList.remove('locked');
    } else {
        if(w.locked) {
            w.el.classList.add('locked');
            if(activeWidgetId === id) activateWidgetId(null); 
        } else {
            w.el.classList.remove('locked');
        }
    }
    renderLayerList();
    playClick();
}

function moveLayer(index, direction) {
    const newIndex = index + direction;

    if (newIndex >= 0 && newIndex < widgets.length) {
        const temp = widgets[index];
        widgets[index] = widgets[newIndex];
        widgets[newIndex] = temp;

        updateLayerZIndices();
        renderLayerList();
        playClick();
    }
}

function deleteWidgetById(id) {
    const index = widgets.findIndex(w => w.id === id);
    if (index > -1) {
        const w = widgets[index];
        if(w.type === 'system' || w.locked) return; 

        w.el.remove();
        widgets.splice(index, 1);
        if (activeWidgetId === id) activateWidgetId(null);
        renderLayerList();
        playClick();
    }
}

function clearAllWidgets() {
    widgets = widgets.filter(w => {
        if(w.type === 'system') return true;
        if(w.locked) return true; 
        w.el.remove();
        return false;
    });
    activeWidgetId = null;
    renderLayerList();
    updateLayerZIndices(); 
    playClick();
    showAlert("Unlocked widgets cleared.");
}

function activateWidgetId(id) {
    document.querySelectorAll('.widget').forEach(el => el.classList.remove('active'));
    document.querySelectorAll('.layer-item').forEach(el => el.classList.remove('active-layer'));

    activeWidgetId = id;

    if (id) {
        const wObj = widgets.find(w => w.id === id);
        if(wObj && wObj.type !== 'system' && !wObj.locked) {
            wObj.el.classList.add('active');
            renderLayerList(); 

            if(wObj.type === 'text') {
                activeWidgetSettings.style.display = 'block';
                widgetTextInput.value = wObj.text;
                widgetColorInput.value = wObj.color;
                widgetSizeInput.value = wObj.fontSize;
            } else {
                activeWidgetSettings.style.display = 'none';
            }
        }
    } else {
        activeWidgetSettings.style.display = 'none';
    }
}

// --- Active Widget Controls ---
function updateActiveWidgetText() {
    if(!activeWidgetId) return;
    const wObj = widgets.find(w => w.id === activeWidgetId);
    if(wObj && wObj.type === 'text') {
        const val = widgetTextInput.value;
        wObj.text = val;
        wObj.el.querySelector('.widget-text-content').innerText = val;
    }
}
function updateActiveWidgetSize() {
    if(!activeWidgetId) return;
    const wObj = widgets.find(w => w.id === activeWidgetId);
    if(wObj && wObj.type === 'text') {
        const val = widgetSizeInput.value;
        wObj.fontSize = val;
        wObj.el.querySelector('.widget-text-content').style.fontSize = val + 'px';
    }
}
function updateActiveWidgetColor() {
    if(!activeWidgetId) return;
    const wObj = widgets.find(w => w.id === activeWidgetId);
    if(wObj && wObj.type === 'text') {
        const val = widgetColorInput.value;
        wObj.color = val;
        wObj.el.querySelector('.widget-text-content').style.color = val;
    }
}


// Global Widget Event Listeners
document.addEventListener('mousedown', handleWidgetStart);
document.addEventListener('touchstart', handleWidgetStart, {passive: false});

document.addEventListener('mousemove', handleWidgetMove);
document.addEventListener('touchmove', handleWidgetMove, {passive: false});

document.addEventListener('mouseup', handleWidgetEnd);
document.addEventListener('touchend', handleWidgetEnd);

function handleWidgetStart(e) {
    if (e.target.closest('.settings-panel') || e.target.closest('.controls')) return;

    if (e.target.isContentEditable) return;

    const target = e.target;
    const clientX = e.clientX || (e.touches ? e.touches[0].clientX : 0);
    const clientY = e.clientY || (e.touches ? e.touches[0].clientY : 0);

    // 1. DELETE
    if (target.classList.contains('w-delete')) {
        playClick();
        const widget = target.closest('.widget');
        deleteWidgetById(widget.id.replace('w-', ''));
        return;
    }

    // 2. ROTATE
    if (target.classList.contains('w-rotate')) {
        e.preventDefault();
        isRotatingWidget = true;
        const widget = target.closest('.widget');
        const rect = widget.getBoundingClientRect();
        startCenterX = rect.left + rect.width / 2;
        startCenterY = rect.top + rect.height / 2;
        startRotation = parseFloat(widget.dataset.rotation) || 0;
        const dx = clientX - startCenterX;
        const dy = clientY - startCenterY;
        startRotation -= Math.atan2(dy, dx) * (180 / Math.PI) + 90; 
        return;
    }

    // 3. RESIZE
    if (target.classList.contains('w-resize')) {
        e.preventDefault();
        isResizingWidget = true;
        const widget = target.closest('.widget');
        const rect = widget.getBoundingClientRect();
        startCenterX = rect.left + rect.width / 2;
        startCenterY = rect.top + rect.height / 2;
        const dx = clientX - startCenterX;
        const dy = clientY - startCenterY;
        const dist = Math.sqrt(dx*dx + dy*dy);
        
        // Setup initial values
        startWidth = parseFloat(widget.style.width) || rect.width;
        startDist = dist; 
        
        const id = widget.id.replace('w-', '');
        const wObj = widgets.find(w => w.id === id);
        if (wObj && wObj.type === 'text') {
            startFontSize = parseFloat(wObj.fontSize) || 50;
        } else {
             startHeight = startWidth / dist; 
        }
        return;
    }

    // 4. DRAG / SELECT
    const widget = target.closest('.widget');
    if (widget) {
        const id = widget.id.replace('w-', '');
        const wObj = widgets.find(w => w.id === id);
        if(wObj && wObj.locked) return; 

        activateWidgetId(id);
        isDraggingWidget = true;
        startX = clientX;
        startY = clientY;
        return;
    } else {
        if(!isDraggingWidget && !isResizingWidget && !isRotatingWidget) {
            activateWidgetId(null);
        }
    }
}

function handleWidgetMove(e) {
    if (!activeWidgetId) return;
    const widget = document.getElementById('w-' + activeWidgetId);
    if (!widget) return;

    const clientX = e.clientX || (e.touches ? e.touches[0].clientX : 0);
    const clientY = e.clientY || (e.touches ? e.touches[0].clientY : 0);

    if (isDraggingWidget) {
        e.preventDefault();
        let dx = clientX - startX;
        let dy = clientY - startY;

        let newLeft = widget.offsetLeft + dx;
        let newTop = widget.offsetTop + dy;

        // SNAP LOGIC
        if (snapToggle.checked) {
            const snapThreshold = 10;
            const centerX = window.innerWidth / 2;
            const centerY = window.innerHeight / 2;

            if (Math.abs(newLeft - centerX) < snapThreshold) {
                newLeft = centerX;
                guideV.style.display = 'block';
            } else {
                guideV.style.display = 'none';
            }

            if (Math.abs(newTop - centerY) < snapThreshold) {
                newTop = centerY;
                guideH.style.display = 'block';
            } else {
                guideH.style.display = 'none';
            }
        } else {
            guideV.style.display = 'none';
            guideH.style.display = 'none';
        }

        widget.style.left = newLeft + 'px';
        widget.style.top = newTop + 'px';

        startX = clientX;
        startY = clientY;

    } else if (isRotatingWidget) {
        e.preventDefault();
        const dx = clientX - startCenterX;
        const dy = clientY - startCenterY;
        const angle = Math.atan2(dy, dx) * (180 / Math.PI) + 90; 
        const finalAngle = angle + startRotation;
        widget.dataset.rotation = finalAngle;
        widget.style.transform = `translate(-50%, -50%) rotate(${finalAngle}deg)`;
    } else if (isResizingWidget) {
        e.preventDefault();
        const dx = clientX - startCenterX;
        const dy = clientY - startCenterY;
        const currentDist = Math.sqrt(dx*dx + dy*dy);
        
        const wObj = widgets.find(w => w.id === activeWidgetId);
        
        if (wObj && wObj.type === 'text') {
            // Text Scaling Logic
            const scaleFactor = currentDist / startDist;
            let newFontSize = startFontSize * scaleFactor;
            
            // Limit font size
            newFontSize = Math.max(10, Math.min(300, newFontSize));
            
            wObj.fontSize = newFontSize;
            widget.querySelector('.widget-text-content').style.fontSize = newFontSize + 'px';
            
            // Sync with settings panel if visible
            if (activeWidgetSettings.style.display !== 'none') {
                widgetSizeInput.value = newFontSize;
            }
        } else {
            // Image/Box Scaling Logic
            let newWidth = currentDist * 2; 
            if (newWidth < 20) newWidth = 20; 
            widget.style.width = newWidth + 'px';
        }
    }
}

function handleWidgetEnd() {
    isDraggingWidget = false;
    isRotatingWidget = false;
    isResizingWidget = false;
    guideV.style.display = 'none';
    guideH.style.display = 'none';
}

/* --- LAYOUT SWITCHER --- */
function changeLayout(mode) {
    playClick();
    document.body.classList.remove('layout-standard', 'layout-inverted', 'layout-split', 'layout-split-rev');

    if (mode === 'standard') {
        document.body.classList.add('layout-standard');
        mainTitle.style.textAlign = 'center';
    } else if (mode === 'inverted') {
        document.body.classList.add('layout-inverted');
        mainTitle.style.textAlign = 'center';
    } else if (mode === 'split') {
        document.body.classList.add('layout-split');
    } else if (mode === 'split-rev') {
        document.body.classList.add('layout-split-rev');
    }
}

/* --- WORLD CLOCK LOGIC --- */
function toggleClockMode() {
    isClockMode = clockToggle.checked;
    clockControls.style.display = isClockMode ? 'block' : 'none';
    playClick();

    if (isClockMode) {
        if (isCuberMode) { cuberToggle.checked = false; toggleCuberMode(); }
        if (isPomoMode) { pomoToggle.checked = false; togglePomoMode(); }

        timerDisplay.style.display = 'none';
        // Removed mainTitle.style.display = 'none'; so title stays if toggle is on
        scrambleDisplay.style.display = 'none';
        statsDisplay.style.display = 'none';

        worldClockContainer.style.display = 'flex';
        updateCitySelection();
        startWorldClock();
    } else {
        worldClockContainer.style.display = 'none';
        stopWorldClock();
    }
    updateLayout(); // Ensure layout logic runs to handle title/clock arrangement
}

function updateCitySelection() {
    const checkboxes = document.querySelectorAll('.city-check');
    selectedCities = [];
    checkboxes.forEach(cb => {
        if(cb.checked) selectedCities.push(cb.value);
    });
    renderCities();
}

function renderCities() {
    citiesGrid.innerHTML = '';
    selectedCities.forEach(city => {
        const div = document.createElement('div');
        div.className = 'city-card';
        div.innerHTML = `
            <div class="city-name">${city}</div>
            <div class="city-time" id="time-${city}">--:--:--</div>
            <div class="city-date" id="date-${city}">--</div>
        `;
        citiesGrid.appendChild(div);
    });
    updateClockTick();
}

function startWorldClock() {
    updateClockTick();
    clockInterval = setInterval(updateClockTick, 1000);
}

function stopWorldClock() {
    clearInterval(clockInterval);
}

function updateClockTick() {
    const now = new Date();

    localTimeDisplay.innerText = now.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit', second: '2-digit'});
    localDateDisplay.innerText = now.toLocaleDateString([], {weekday: 'short', month: 'short', day: 'numeric'});

    selectedCities.forEach(city => {
        const tz = cityTimeZones[city];
        if (!tz) return;

        try {
            const timeStr = now.toLocaleTimeString('en-US', { timeZone: tz, hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit' });
            const dateStr = now.toLocaleDateString('en-US', { timeZone: tz, month: 'short', day: 'numeric' });

            const timeEl = document.getElementById(`time-${city}`);
            const dateEl = document.getElementById(`date-${city}`);
            if(timeEl) timeEl.innerText = timeStr;
            if(dateEl) dateEl.innerText = dateStr;
        } catch(e) { console.error(e); }
    });
}

/* --- LYRIC SYNC & AUDIO --- */
function toggleLyricMode() {
    isLyricMode = document.getElementById('lyricToggle').checked;
    lyricControls.style.display = isLyricMode ? 'block' : 'none';
    if (isLyricMode) {
        mainTitle.setAttribute('contenteditable', 'false');
        parseLyrics(); 
    } else {
        stopLyrics();
        if(lyricAudio) { lyricAudio.pause(); lyricAudio.currentTime = lyricStartTime; }
        mainTitle.setAttribute('contenteditable', 'true');
        mainTitle.innerText = "Made by CircleSide with Gemini!";
        mainTitle.style.opacity = 1;
    }
    playClick();
}

lyricInput.addEventListener('input', parseLyrics);

lyricAudioInput.addEventListener('change', function(e) {
    const file = e.target.files[0];
    if (!file) return;

    if(lyricAudio) { lyricAudio.pause(); lyricAudio = null; }
    lyricAudio = new Audio(URL.createObjectURL(file));
    lyricAudioStatus.innerText = "Loaded: " + file.name;
    lyricAudioSettings.style.display = 'block'; 

    lyricAudio.addEventListener('loadedmetadata', () => {
        const dur = lyricAudio.duration;
        lyricTrimStartInput.max = dur;
        lyricTrimDurInput.max = dur;
        lyricTrimStartInput.value = 0;
        lyricTrimDurInput.value = dur;

        updateLyricTrim(); 
        showAlert("Song Loaded!<br>Trimmer controls unlocked.");
    });

    const reader = new FileReader();
    reader.onload = function(ev) {
        const text = ev.target.result;
        const lrcPattern = /\[\d{2}:\d{2}(\.\d{2,3})?\].*/g;
        const matches = text.match(lrcPattern);

        if (matches && matches.length > 5) {
            lyricInput.value = matches.join('\n');
            parseLyrics();
            showAlert("Found Embedded Lyrics!");
        }
    };
    reader.readAsText(file, "ISO-8859-1");
});

function clearLyricAudio() {
    if(lyricAudio) { lyricAudio.pause(); lyricAudio = null; }
    lyricAudioInput.value = "";
    lyricAudioStatus.innerText = "No file chosen";
    lyricAudioSettings.style.display = 'none';
    showAlert("Song Removed");
}

function updateLyricTrim() {
    if(!lyricAudio) return;
    lyricStartTime = parseFloat(lyricTrimStartInput.value);
    lyricDuration = parseFloat(lyricTrimDurInput.value);

    if(lyricStartTime + lyricDuration > lyricAudio.duration) {
        lyricDuration = lyricAudio.duration - lyricStartTime;
        lyricTrimDurInput.value = lyricDuration;
    }

    lyricTrimStartVal.innerText = lyricStartTime.toFixed(1) + "s";
    lyricTrimDurVal.innerText = lyricDuration.toFixed(1) + "s";

    if(!isRunning) {
        timeLeft = Math.floor(lyricDuration * 1000);
        originalTime = timeLeft;
        updateDisplay();
    }
}

function updateLyricVolume(val) {
    if(lyricAudio) lyricAudio.volume = val / 100;
}

function parseLyrics() {
    const raw = lyricInput.value.trim();
    if(!raw) {
        lyricLines = ["Paste Lyrics", "In Settings"];
        isLrcFormat = false;
    } else {
        const lrcRegex = /^\[(\d{2}):(\d{2})(?:\.(\d{2,3}))?\](.*)$/;
        const lines = raw.split('\n');
        const hasTimestamps = lines.some(line => lrcRegex.test(line.trim()));

        if (hasTimestamps) {
            isLrcFormat = true;
            lyricLines = [];
            lines.forEach(line => {
                const match = line.match(lrcRegex);
                if (match) {
                    const min = parseInt(match[1]);
                    const sec = parseInt(match[2]);
                    const ms = match[3] ? parseInt(match[3]) : 0;
                    const timeVal = min * 60 + sec + (ms / (match[3].length === 3 ? 1000 : 100));
                    lyricLines.push({ time: timeVal, text: match[4].trim() });
                }
            });
            lyricLines.sort((a,b) => a.time - b.time);
        } else {
            isLrcFormat = false;
            lyricLines = lines.filter(l => l.trim() !== '');
        }
    }
    if(isLrcFormat) {
        speedControlGroup.style.display = 'none'; lrcStatus.style.display = 'block';
    } else {
        speedControlGroup.style.display = 'flex'; lrcStatus.style.display = 'none';
    }
}

function startLyrics() {
    if (!isLyricMode || lyricLines.length === 0) return;
    lyricIndex = 0;
    if (isLrcFormat) { mainTitle.innerText = ""; } 
    else {
        updateSimpleLyric();
        const speed = parseInt(lyricSpeedInput.value) * 1000;
        lyricInterval = setInterval(nextSimpleLyric, speed);
    }
}

function stopLyrics() {
    clearInterval(lyricInterval);
    mainTitle.classList.remove('lyric-fade-out', 'lyric-fade-in');
}

function nextSimpleLyric() {
    mainTitle.classList.remove('lyric-fade-in'); mainTitle.classList.add('lyric-fade-out');
    setTimeout(() => {
        lyricIndex = (lyricIndex + 1) % lyricLines.length;
        updateSimpleLyric();
        mainTitle.classList.remove('lyric-fade-out'); mainTitle.classList.add('lyric-fade-in');
    }, 300);
}
function updateSimpleLyric() { mainTitle.innerText = lyricLines[lyricIndex]; }

function checkLrcSync(elapsedTime) {
    let activeText = "";
    const absoluteAudioTime = lyricStartTime + elapsedTime;

    for (let i = 0; i < lyricLines.length; i++) {
        if (absoluteAudioTime >= lyricLines[i].time) activeText = lyricLines[i].text; else break;
    }

    if (mainTitle.innerText !== activeText) {
        mainTitle.classList.remove('glitch-active');
        void mainTitle.offsetWidth; 
        mainTitle.classList.add('glitch-active');
        mainTitle.innerText = activeText;
        setTimeout(() => { mainTitle.classList.remove('glitch-active'); }, 500);
    }
}

/* --- CUSTOM ALERT SYSTEM --- */
function showAlert(msg) { alertMsg.innerHTML = msg; customAlert.classList.add('active'); playClick(); }
function closeAlert() { customAlert.classList.remove('active'); }

/* --- FONT ANIMATION --- */
function changeFont() {
    const selectedFont = fontSelect.value;
    playClick();
    timerDisplay.classList.add('glitch-active');
    mainTitle.classList.add('glitch-active');
    scrambleDisplay.classList.add('glitch-active');
    localTimeDisplay.classList.add('glitch-active');

    setTimeout(() => {
        document.documentElement.style.setProperty('--current-font', selectedFont);
        if (selectedFont.includes('Press Start 2P')) document.body.classList.add('retro-mode');
        else document.body.classList.remove('retro-mode');
    }, 200);
    setTimeout(() => {
        timerDisplay.classList.remove('glitch-active');
        mainTitle.classList.remove('glitch-active');
        scrambleDisplay.classList.remove('glitch-active');
        localTimeDisplay.classList.remove('glitch-active');
    }, 550);
}

/* --- DRAGGABLE & RESIZABLE LOGIC --- */
let isDragging = false;
let dragOffsetX = 0, dragOffsetY = 0;

panelHeader.addEventListener('mousedown', startDrag);
panelHeader.addEventListener('touchstart', startDrag, {passive: false});

function startDrag(e) {
    if(e.target.closest('.close-btn') || e.target.tagName === 'BUTTON') return;
    const rect = settingsPanel.getBoundingClientRect();
    const x = e.clientX || e.touches[0].clientX;
    const y = e.clientY || e.touches[0].clientY;
    if (x > rect.right - 20 || y > rect.bottom - 20 || x < rect.left + 10 || y < rect.top + 10) return; 

    e.preventDefault(); isDragging = true;
    dragOffsetX = x - rect.left; dragOffsetY = y - rect.top;

    document.addEventListener('mousemove', dragWindow);
    document.addEventListener('touchmove', dragWindow, {passive: false});
    document.addEventListener('mouseup', stopDrag);
    document.addEventListener('touchend', stopDrag);
}

function dragWindow(e) {
    if (!isDragging) return;
    e.preventDefault();
    const x = e.clientX || e.touches[0].clientX;
    const y = e.clientY || e.touches[0].clientY;
    let newLeft = x - dragOffsetX; let newTop = y - dragOffsetY;
    if (newLeft < 0) newLeft = 0; if (newTop < 0) newTop = 0;
    settingsPanel.style.left = `${newLeft}px`; settingsPanel.style.top = `${newTop}px`;
}

function stopDrag() {
    isDragging = false;
    document.removeEventListener('mousemove', dragWindow);
    document.removeEventListener('touchmove', dragWindow);
    document.removeEventListener('mouseup', stopDrag);
    document.removeEventListener('touchend', stopDrag);
}

/* --- COLORS & PATTERNS --- */
function updateColors(hex) {
    document.documentElement.style.setProperty('--bg-color', hex);
    const c = hex.replace("#", "");
    const r = parseInt(c.substr(0,2),16), g = parseInt(c.substr(2,2),16), b = parseInt(c.substr(4,2),16);
    const yiq = ((r*299)+(g*587)+(b*114))/1000;
    const contrast = (yiq >= 128) ? '#000000' : '#ffffff';
    document.documentElement.style.setProperty('--text-color', contrast);
    document.documentElement.style.setProperty('--accent', hex);

    let panelBg, panelText, innerPanelBg, inputBg;
    if(contrast === '#ffffff') {
        panelBg = 'rgba(20, 20, 20, 0.95)';
        panelText = '#ffffff';
        innerPanelBg = 'rgba(255, 255, 255, 0.1)';
        inputBg = 'rgba(0, 0, 0, 0.2)';
    } else {
        panelBg = 'rgba(245, 245, 245, 0.95)';
        panelText = '#000000';
        innerPanelBg = 'rgba(0, 0, 0, 0.05)';
        inputBg = 'rgba(255, 255, 255, 0.5)';
    }

    document.documentElement.style.setProperty('--panel-bg', panelBg);
    document.documentElement.style.setProperty('--panel-text', panelText);
    document.documentElement.style.setProperty('--inner-panel-bg', innerPanelBg);
    document.documentElement.style.setProperty('--input-bg', inputBg);
}
colorPicker.addEventListener('input', (e) => updateColors(e.target.value));

function updateBgParams() {
    const zoom = sliderZoom.value, panX = sliderPanX.value, panY = sliderPanY.value;
    document.body.style.backgroundPosition = `${panX}% ${panY}%`;
    document.body.style.backgroundSize = currentBgMode === 'image' ? `${zoom}%` : `${zoom}px ${zoom}px`;
}

function selectPattern(type) {
    playClick();
    currentBgMode = (type === 'none') ? 'none' : 'pattern';
    currentPatternType = type;
    document.body.classList.remove('custom-image-mode');
    if (type !== 'none') { sliderZoom.value = 30; sliderPanX.value = 50; sliderPanY.value = 50; }
    updatePatternStyle(); updateBgParams();      
}

function updatePatternStyle() {
    const blend = blendToggle.checked ? 'overlay' : 'normal';
    document.documentElement.style.setProperty('--bg-blend', blend);
    if (currentBgMode === 'image') return; 
    if (currentPatternType === 'none') { document.body.style.backgroundImage = 'none'; return; }

    const hex = patColorInput.value;
    const op = patOpacityInput.value / 100;

    let svg = '';
    const t = currentPatternType;
    if(t==='dots') svg=`<circle cx="10" cy="10" r="5" fill="${hex}" opacity="${op}"/>`;
    else if(t==='stripes') svg=`<path d="M0 20 L20 0 L10 0 L0 10 Z" fill="${hex}" opacity="${op}"/><path d="M10 20 L20 10 L20 20 Z" fill="white" opacity="0.6"/></svg>`;
    else if(t==='grid') svg=`<path d="M10 0 L10 20 M0 10 L20 10" stroke="${hex}" stroke-width="2" opacity="${op}"/>`;
    else if(t==='check') svg=`<rect x="0" y="0" width="10" height="10" fill="${hex}" opacity="${op}"/><rect x="10" y="10" width="10" height="10" fill="white" opacity="0.5"/></svg>`;
    else if(t==='zig') svg=`<path d="M0 0 L10 10 L20 0 L20 5 L10 15 L0 5 Z" fill="${hex}" opacity="${op}"/>`;

    document.body.style.backgroundImage = `url("data:image/svg+xml;utf8,<svg width='20' height='20' xmlns='http://www.w3.org/2000/svg'>${encodeURIComponent(svg)}</svg>")`;
}

document.getElementById('bgImageFile').addEventListener('change', function(e) {
    const file = e.target.files[0]; if (!file) return;
    const reader = new FileReader();
    reader.onload = function(ev) {
        currentBgMode = 'image'; sliderZoom.value = 100; sliderPanX.value = 50; sliderPanY.value = 50;
        document.body.style.backgroundImage = `url("${ev.target.result}")`;
        document.body.classList.add('custom-image-mode');
        updatePatternStyle(); updateBgParams(); playClick(); 
        showAlert("Background Image Loaded!");
    }; reader.readAsDataURL(file);
});

/* --- TIMER CORE --- */
function updateLayout() {
    const hasTitle = document.getElementById('titleToggle').checked;
    
    // Ensure title visibility setting is respected
    mainTitle.style.display = hasTitle ? 'block' : 'none';

    if(isClockMode) {
        timerDisplay.style.display = 'none';
        return;
    }
    
    const showMs = document.getElementById('msToggle').checked || isCuberMode;
    const hasTimer = timerDisplay.innerText.trim() !== "";
    
    timerDisplay.style.display = hasTimer ? 'inline-block' : 'none';
    if (showMs) timerDisplay.classList.add('ms-mode'); else timerDisplay.classList.remove('ms-mode');

    if (hasTitle && hasTimer) { timerDisplay.classList.add('shrink-mode'); mainTitle.classList.remove('solo-mode'); }
    else if (!hasTitle && hasTimer) { timerDisplay.classList.remove('shrink-mode'); }
    else if (hasTitle && !hasTimer) { mainTitle.classList.add('solo-mode'); }
}

function updateDisplay() {
    if (isEditing) return;
    const ts = Math.floor(timeLeft / 1000);
    const m = Math.floor(ts / 60);
    const s = ts % 60;
    const ms = Math.floor((timeLeft % 1000) / 10); 
    let d = `${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
    if (document.getElementById('msToggle').checked || isCuberMode) d += `.${ms.toString().padStart(2, '0')}`;
    timerDisplay.innerText = d;
}

function generateScramble() {
    const moves = ['R', 'L', 'U', 'D', 'F', 'B'];
    const modifiers = ['', "'", '2'];
    let scramble = [], lastMove = '';
    for (let i = 0; i < 20; i++) {
        let move; do { move = moves[Math.floor(Math.random() * moves.length)]; } while (move === lastMove);
        lastMove = move;
        scramble.push(move + modifiers[Math.floor(Math.random() * modifiers.length)]);
    }
    scrambleDisplay.textContent = scramble.join(' ');
}

function toggleTimer() { 
    if(isClockMode) return; 
    isRunning ? pauseTimer() : startTimer(); 
}

function startTimer() {
    if (isRunning) return;
    stopAlarm(); 
    if (audioCtx.state === 'suspended') audioCtx.resume();
    if (isEditing) { parseInputTime(); isEditing = false; }
    isRunning = true;
    document.getElementById('toggleBtn').innerText = "Pause";
    lastSecond = Math.floor(timeLeft / 1000);
    const now = Date.now();
    if (isCuberMode) timerStartTime = now - timeLeft; else timerEndTime = now + timeLeft;

    if (isLyricMode) {
        startLyrics();
        if(lyricAudio) {
            lyricAudio.currentTime = lyricStartTime + (originalTime - timeLeft) / 1000;
            lyricAudio.play();
        }
    }

    timerInterval = setInterval(() => {
        const now = Date.now();
        let elapsed = 0;

        if (isCuberMode) {
            timeLeft = now - timerStartTime;
            elapsed = timeLeft / 1000;
        } else {
            timeLeft = timerEndTime - now;
            elapsed = (originalTime - timeLeft) / 1000;

            if (timeLeft > 0) {
                const cs = Math.floor(timeLeft / 1000);
                if (cs < lastSecond) { playTick(); lastSecond = cs; }
            } else {
                timeLeft = 0; updateDisplay(); pauseTimer(); playAlarm();

                if(isPomoMode) {
                    if(pomoState === 'work') {
                        pomoState = 'short';
                        timeLeft = pomoShortTime * 60 * 1000;
                        originalTime = timeLeft;
                        updatePomoUI();
                        showAlert("Break Time! ‚òï<br>Click Start when ready.");
                    } else {
                        pomoState = 'work';
                        timeLeft = pomoWorkTime * 60 * 1000;
                        originalTime = timeLeft;
                        updatePomoUI();
                        showAlert("Back to Work! üí™<br>Click Start.");
                    }
                    updateDisplay();
                }
            }
        }

        if(lyricAudio && !lyricAudio.paused) {
            const expectedTime = lyricStartTime + elapsed;
            if(Math.abs(lyricAudio.currentTime - expectedTime) > 0.5) {
                lyricAudio.currentTime = expectedTime;
            }
        }

        if(isLyricMode && isLrcFormat && isRunning) checkLrcSync(elapsed);

        updateDisplay();
    }, 10);
}

function pauseTimer() { 
    clearInterval(timerInterval); 
    isRunning = false; 
    document.getElementById('toggleBtn').innerText = "Start"; 
    stopAlarm();
    if (isLyricMode) {
        stopLyrics();
        if(lyricAudio) lyricAudio.pause();
    }
}

function resetTimer() {
    if(isClockMode) return;
    pauseTimer(); 

    if(isLyricMode && lyricAudio) {
        timeLeft = Math.floor(lyricDuration * 1000);
        originalTime = timeLeft;
        lyricAudio.currentTime = lyricStartTime;
    } else {
        timeLeft = originalTime;
    }

    stopAlarm();
    if (isCuberMode) { 
        timeLeft = 0; 
        generateScramble(); 
        timerDisplay.classList.remove('cuber-stopped'); 
    }
    updateDisplay(); if(timerDisplay.innerText === "") { updateDisplay(); updateLayout(); }
}

function toggleCuberMode() {
    isCuberMode = cuberToggle.checked; playClick();
    stopAlarm();
    if(isCuberMode) {
        if(isPomoMode) { pomoToggle.checked = false; togglePomoMode(); }
        if(isClockMode) { clockToggle.checked = false; toggleClockMode(); }

        pauseTimer(); timeLeft = 0; originalTime = 0; generateScramble();
        scrambleDisplay.style.display = 'block'; updateDisplay();
        statsDisplay.style.display = 'flex'; 
        timerDisplay.setAttribute('contenteditable', 'false');
        showAlert("Cuber Mode:<br>1. Hold screen/space to Arm.<br>2. Release to Solve.");
    } else {
        scrambleDisplay.style.display = 'none';
        statsDisplay.style.display = 'none'; 
        timerDisplay.setAttribute('contenteditable', 'true');
        timeLeft = 300000; originalTime = 300000; updateDisplay();
        timerDisplay.classList.remove('cuber-holding', 'cuber-stopped');
    }
    updateLayout();
}

/* --- CUBER HISTORY UI --- */
function updateLastSolvesUI() {
    statsDisplay.innerHTML = '';
    solveHistory.forEach((solve, index) => {
        const div = document.createElement('div');
        div.className = 'stat-item';
        div.innerHTML = `
            <div class="stat-header">
                <span class="stat-index">#${solveHistory.length - index}</span>
                <span class="stat-time">${solve.time}</span>
            </div>
            <div class="stat-scramble">${solve.scramble}</div>
        `;
        statsDisplay.appendChild(div);
    });
}

/* --- POMODORO LOGIC --- */
function togglePomoMode() {
    isPomoMode = pomoToggle.checked;
    pomoControls.style.display = isPomoMode ? 'block' : 'none';
    pomoStatus.style.display = isPomoMode ? 'block' : 'none';
    playClick();

    if (isPomoMode) {
        if(isCuberMode) { cuberToggle.checked = false; toggleCuberMode(); }
        if(isClockMode) { clockToggle.checked = false; toggleClockMode(); }

        updatePomoSettings();
        pomoState = 'work';
        timeLeft = pomoWorkTime * 60 * 1000;
        originalTime = timeLeft;
        updatePomoUI();
        updateDisplay();
        timerDisplay.setAttribute('contenteditable', 'false');
    } else {
        timerDisplay.setAttribute('contenteditable', 'true');
        pomoStatus.style.display = 'none';
    }
}

function updatePomoSettings() {
    pomoWorkTime = parseInt(pomoWorkInput.value);
    pomoShortTime = parseInt(pomoShortInput.value);
    pomoLongTime = parseInt(pomoLongInput.value);
    if(!isRunning && isPomoMode && pomoState === 'work') {
        timeLeft = pomoWorkTime * 60 * 1000; originalTime = timeLeft; updateDisplay();
    }
}

function updatePomoUI() {
    if(pomoState === 'work') {
        pomoStatus.innerText = "üí™ FOCUS MODE";
        pomoStatus.style.color = "#ffffff";
        pomoStatus.style.background = "rgba(231, 76, 60, 0.4)";
    } else if (pomoState === 'short') {
        pomoStatus.innerText = "‚òï SHORT BREAK";
        pomoStatus.style.color = "#ffffff";
        pomoStatus.style.background = "rgba(46, 204, 113, 0.4)";
    } else if (pomoState === 'long') {
        pomoStatus.innerText = "üßò LONG BREAK";
        pomoStatus.style.color = "#ffffff";
        pomoStatus.style.background = "rgba(52, 152, 219, 0.4)";
    }
}

function toggleTitleVisibility() { updateLayout(); playClick(); }
function toggleMsVisibility() { updateLayout(); updateDisplay(); playClick(); }

/* --- INPUT HANDLERS --- */
const handleInputDown = (e) => {
    const target = e.target;
    const isControl = target.closest('.controls') || target.closest('.settings-panel') || target.closest('.custom-alert-box') || target.tagName === 'BUTTON' || target.tagName === 'INPUT' || target.tagName === 'SELECT' || target.tagName === 'TEXTAREA' || target.closest('.detached');
    const isEditable = target.id === 'timer' || target.id === 'mainTitle';

    if (target.closest('.widget')) return;

    if (document.body.classList.contains('fullscreen-mode') && !isControl && !isRunning && !isEditable) document.body.classList.toggle('show-controls');
    if (!isCuberMode || isControl || (isEditable && !isCuberMode)) return;

    e.preventDefault();
    if (isRunning) { 
        pauseTimer(); playClick(); document.body.classList.remove('cuber-running');

        const currentScramble = scrambleDisplay.innerText;
        const currentTime = timerDisplay.innerText;
        solveHistory.unshift({ time: currentTime, scramble: currentScramble });
        if(solveHistory.length > 3) solveHistory.pop();
        updateLastSolvesUI();

        timerDisplay.classList.add('cuber-stopped'); 
    } else { 
        if (timerDisplay.classList.contains('cuber-stopped')) {
            generateScramble();
        }

        pauseTimer(); timeLeft = 0; updateDisplay(); 
        timerDisplay.classList.remove('cuber-stopped'); 
        timerDisplay.classList.add('not-ready'); 
        holdTimeout = setTimeout(() => { 
            timerDisplay.classList.remove('not-ready'); 
            timerDisplay.classList.add('cuber-holding'); 
            isArmed = true; 
            playTick(); 
        }, 300); 
    }
};

const handleInputUp = (e) => {
    if (!isCuberMode) return;
    clearTimeout(holdTimeout); 
    timerDisplay.classList.remove('not-ready');

    if (isArmed) { 
        timerDisplay.classList.remove('cuber-holding'); 
        isArmed = false; 
        startTimer(); 
        document.body.classList.add('cuber-running'); 
    } else { 
        timerDisplay.classList.remove('cuber-holding'); 
    }
};

document.body.addEventListener('touchstart', handleInputDown, {passive: false});
document.body.addEventListener('mousedown', handleInputDown);
document.body.addEventListener('touchend', handleInputUp);
document.body.addEventListener('mouseup', handleInputUp);

const forceFocus = (e) => { if(!isCuberMode && !isPomoMode && !isClockMode) e.target.focus(); };
timerDisplay.addEventListener('click', forceFocus); mainTitle.addEventListener('click', forceFocus);

/* --- AUDIO & ALARM SYSTEM --- */
function stopAlarm() {
    clearTimeout(alarmTimeout);
    clearInterval(alarmInterval);
    if (activeAlarmSource) { try { activeAlarmSource.stop(); } catch(e) {} activeAlarmSource = null; }
}

function playAlarm() {
    if (volAlarm <= 0) return;
    stopAlarm(); 
    if (audioCtx.state === 'suspended') audioCtx.resume();
    const TOTAL_ALARM_TIME = 5000;

    if (customAlarmBuffer) {
        const start = parseFloat(trimStartInput.value) || 0;
        const dur = parseFloat(trimDurInput.value) || audioDuration;

        const playSegment = () => {
            activeAlarmSource = audioCtx.createBufferSource();
            const gainNode = audioCtx.createGain();
            activeAlarmSource.buffer = customAlarmBuffer;
            gainNode.gain.value = volAlarm;
            activeAlarmSource.connect(gainNode); gainNode.connect(audioCtx.destination);
            activeAlarmSource.start(0, start, dur);
        };
        playSegment();
        alarmInterval = setInterval(playSegment, dur * 1000);
        alarmTimeout = setTimeout(stopAlarm, TOTAL_ALARM_TIME);
    } else {
        const playBeepBoop = () => {
            const now = audioCtx.currentTime;
            playToneAt(600, 'sine', 1, volAlarm, now);
            playToneAt(400, 'sine', 1.5, volAlarm, now + 0.4);
        };
        playBeepBoop(); 
        alarmInterval = setInterval(playBeepBoop, 1500); 
        alarmTimeout = setTimeout(stopAlarm, TOTAL_ALARM_TIME);
    }
}

function playToneAt(f, t, d, v, when) {
    const o = audioCtx.createOscillator(); const g = audioCtx.createGain();
    o.type = t; o.frequency.setValueAtTime(f, when); g.gain.setValueAtTime(v, when);
    g.gain.exponentialRampToValueAtTime(0.0001, when + d);
    o.connect(g); g.connect(audioCtx.destination); o.start(when); o.stop(when + d);
}

function playTone(f, t, d, v) { playToneAt(f, t, d, v, audioCtx.currentTime); }
function playClick() { playTone(800, 'sine', 0.1, volClick); }
function playTick() { playTone(1000, 'triangle', 0.05, volTick); }

// AUDIO MANIPULATION
document.getElementById('audioFile').addEventListener('change', function(e) {
    if(e.target.files[0]) {
        const r = new FileReader();
        r.onload = ev => audioCtx.decodeAudioData(ev.target.result, b => { 
            customAlarmBuffer = b; audioDuration = b.duration;
            trimmerDiv.style.display = 'flex';
            trimStartInput.max = audioDuration; trimDurInput.max = audioDuration;
            trimStartInput.value = 0; trimDurInput.value = audioDuration;
            trimStartVal.innerText = "0.0s"; trimDurVal.innerText = audioDuration.toFixed(1) + "s";
            playClick(); showAlert("Alarm Loaded!"); 
        });
        r.readAsArrayBuffer(e.target.files[0]);
    }
});

function playCustomPreview() {
    if (volAlarm <= 0) return;
    if (audioCtx.state === 'suspended') audioCtx.resume();
    stopAlarm(); 

    if (customAlarmBuffer) {
        const start = parseFloat(trimStartInput.value);
        const dur = parseFloat(trimDurInput.value);
        activeAlarmSource = audioCtx.createBufferSource();
        const gainNode = audioCtx.createGain();
        activeAlarmSource.buffer = customAlarmBuffer;
        gainNode.gain.value = volAlarm;
        activeAlarmSource.connect(gainNode); gainNode.connect(audioCtx.destination);
        activeAlarmSource.start(0, start, dur);
    } else {
        playAlarm(); 
    }
}

function clearCustomAudio() {
    customAlarmBuffer = null;
    document.getElementById('audioFile').value = ""; 
    trimmerDiv.style.display = 'none';
    playClick();
    showAlert("Custom Alarm Removed.<br>Reverted to Default.");
}

trimStartInput.addEventListener('input', (e) => { trimStartVal.innerText = parseFloat(e.target.value).toFixed(1) + "s"; });
trimDurInput.addEventListener('input', (e) => { trimDurVal.innerText = parseFloat(e.target.value).toFixed(1) + "s"; });

/* --- UI CONTROLS --- */
function toggleSettings() { settingsPanel.classList.toggle('hidden'); }
function toggleFullScreen() {
    settingsPanel.classList.add('hidden');
    if (!document.fullscreenElement) document.documentElement.requestFullscreen().catch(console.log);
    else if (document.exitFullscreen) document.exitFullscreen();
}
document.addEventListener('fullscreenchange', () => {
    if (!document.fullscreenElement) { document.body.classList.remove('fullscreen-mode', 'show-controls'); }
    else { document.body.classList.add('fullscreen-mode'); document.body.classList.remove('show-controls'); }
});

/* --- TEXT EDITING --- */
timerDisplay.addEventListener('focus', () => { if(isCuberMode || isPomoMode || isClockMode) { timerDisplay.blur(); return; } isEditing = true; pauseTimer(); });
timerDisplay.addEventListener('blur', () => { 
    if(isCuberMode || isPomoMode || isClockMode) return;
    let txt = timerDisplay.innerText.trim();
    if (txt === "") { updateLayout(); isEditing = false; return; }
    let s = 0;
    if (txt.includes(':')) { const p = txt.split(':'); s = (parseInt(p[0])||0)*60 + (parseFloat(p[1])||0); } 
    else { s = parseFloat(txt)||0; }
    timeLeft = Math.floor(s * 1000); originalTime = timeLeft; isEditing = false; updateDisplay(); updateLayout();
});
timerDisplay.addEventListener('keydown', (e) => { if (e.key === 'Enter') { e.preventDefault(); timerDisplay.blur(); } });

window.addEventListener('DOMContentLoaded', init);
</script>
</body>
</html>

