<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Tenshon Timer</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Bangers&family=Caveat&family=Inter:wght@400;800&family=JetBrains+Mono:wght@700&family=Lobster&family=Orbitron:wght@700&family=Oswald:wght@500&family=Pacifico&family=Playfair+Display:wght@700&family=Press+Start+2P&family=Roboto:wght@400;700&display=swap');

        :root {
            --bg-color: #3498db;
            --text-color: #ffffff;
            --panel-bg: rgba(20, 20, 20, 0.95); 
            --panel-text: #ffffff;
            --bg-blend: overlay;
            --current-font: 'Inter', sans-serif;
        }

        body {
            margin: 0;
            height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-color: var(--bg-color);
            background-repeat: repeat;
            background-position: center;
            background-blend-mode: var(--bg-blend);
            color: var(--text-color);
            font-family: var(--current-font);
            transition: background-color 0.5s ease, color 0.5s ease, font-family 0.3s ease;
            text-align: center;
            overflow: hidden;
            /* user-select: none is kept for the body, but overridden for editable elements below */
            user-select: none;
            -webkit-user-select: none;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }

        body.custom-image-mode { background-repeat: no-repeat !important; }

        .container {
            position: relative;
            z-index: 1;
            width: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            flex-grow: 1; 
        }

        /* Scramble Text */
        .scramble-display {
            font-family: 'JetBrains Mono', monospace;
            font-size: 3vh; 
            margin-bottom: 2vh;
            max-width: 95%;
            line-height: 1.2;
            display: none;
            opacity: 0.9;
            font-weight: bold;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
            pointer-events: none;
            text-align: center;
            word-wrap: break-word;
        }

        body.fullscreen-mode .scramble-display { font-size: 4vh; margin-bottom: 4vh; }

        h1 {
            font-size: 5vw;
            margin: 0;
            outline: none;
            border: 1px solid transparent;
            cursor: text;
            display: none;
            padding: 0 10px;
            border-radius: 10px;
            line-height: 1.2;
            width: 80%;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
            font-family: inherit;
            white-space: nowrap;
            
            /* FIX FOR MOBILE EDITING */
            user-select: text;
            -webkit-user-select: text;
            pointer-events: auto;
        }

        h1.solo-mode { font-size: 15vw; display: block; }
        h1:hover { background: rgba(255,255,255,0.1); }
        h1:focus { background: rgba(255,255,255,0.2); border-bottom: 2px solid var(--text-color); }

        /* --- ROBUST TIMER SCALING --- */
        .timer-display {
            font-weight: bold;
            font-variant-numeric: tabular-nums; 
            cursor: text; /* Changed from pointer to text to imply editing */
            line-height: 1;
            outline: none;
            border-bottom: 2px solid transparent;
            display: inline-block;
            transition: font-size 0.3s ease, color 0.1s;
            text-shadow: 0 4px 8px rgba(0,0,0,0.2);
            font-family: inherit;
            white-space: nowrap; 
            
            /* FIX FOR MOBILE EDITING */
            user-select: text;
            -webkit-user-select: text;
            pointer-events: auto;

            /* Standard Size (05:00) */
            font-size: 22vw; 
        }

        /* MILLISECONDS / CUBER MODE (00:00.00) */
        /* Must shrink to fit the extra digits */
        .timer-display.ms-mode {
            font-size: 14vw !important; 
        }

        /* RETRO FONT OVERRIDES */
        body.retro-mode h1 { font-size: 3vw !important; }
        /* Retro Standard */
        body.retro-mode .timer-display { font-size: 15vw !important; letter-spacing: -2px; }
        /* Retro + Milliseconds (Needs aggressive shrinking) */
        body.retro-mode .timer-display.ms-mode { font-size: 9vw !important; letter-spacing: -3px; }

        /* Fullscreen adjustments */
        body.fullscreen-mode .timer-display { font-size: 30vw; }
        body.fullscreen-mode .timer-display.ms-mode { font-size: 18vw !important; }
        body.fullscreen-mode.retro-mode .timer-display { font-size: 20vw !important; }
        body.fullscreen-mode.retro-mode .timer-display.ms-mode { font-size: 12vw !important; }

        .timer-display.not-ready { color: #e74c3c !important; }
        .timer-display.ready { color: #2ecc71 !important; }
        .timer-display.shrink-mode { font-size: 15vw; }
        body.fullscreen-mode .timer-display.shrink-mode { font-size: 20vw; }
        body.fullscreen-mode h1.solo-mode { font-size: 20vw; }

        /* --- SETTINGS PANEL --- */
        .settings-panel {
            position: fixed;
            bottom: 80px;
            background-color: var(--panel-bg); 
            color: var(--panel-text);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            padding: 15px;
            border-radius: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.6);
            transition: opacity 0.3s, transform 0.3s, background-color 0.5s ease;
            z-index: 101;
            min-width: 280px;
            max-height: 70vh; 
            overflow-y: auto;
            border: 1px solid rgba(128, 128, 128, 0.4); 
            font-family: 'Segoe UI', sans-serif;
        }

        .settings-panel.hidden { opacity: 0; pointer-events: none; transform: translateY(20px); }
        .settings-panel::-webkit-scrollbar { width: 6px; }
        .settings-panel::-webkit-scrollbar-thumb { background: rgba(128,128,128,0.5); border-radius: 3px; }

        .section-title, .slider-group, .toggle-group label, .file-upload-group label {
            color: inherit;
            font-size: 0.85rem;
            font-weight: bold;
        }
        
        .section-title {
            text-transform: uppercase;
            letter-spacing: 1px;
            opacity: 0.8;
            margin-bottom: 5px;
            border-bottom: 1px solid rgba(128,128,128,0.3);
            padding-bottom: 3px;
        }

        .slider-group { display: flex; align-items: center; justify-content: space-between; gap: 10px; }
        
        /* Clickable Labels */
        .toggle-row {
            display: flex; 
            justify-content: space-between; 
            align-items: center; 
            width: 100%;
            cursor: pointer; /* Makes the whole row clickable */
        }
        .toggle-row label { cursor: pointer; flex-grow: 1; }

        .toggle-group { display: flex; flex-direction: column; gap: 10px; }
        .file-upload-group { display: flex; flex-direction: column; gap: 5px; }

        select {
            width: 100%;
            padding: 8px;
            border-radius: 10px;
            border: 1px solid rgba(128,128,128,0.5);
            background: rgba(255,255,255,0.1);
            color: inherit;
            font-weight: bold;
            cursor: pointer;
            outline: none;
        }
        select option { background: #222; color: white; }

        .pattern-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            margin-bottom: 5px;
        }
        
        /* Pattern Buttons */
        .pattern-btn {
            height: 45px;
            border-radius: 8px;
            border: 1px solid rgba(255,255,255,0.3);
            cursor: pointer;
            transition: transform 0.1s, border-color 0.2s;
            background-color: #222 !important; 
            background-size: cover;
            background-position: center;
        }
        .pattern-btn:hover { transform: scale(1.05); border-color: #fff; }
        .pattern-btn:active { transform: scale(0.95); }

        .pat-none { background: #222; position: relative; }
        .pat-none::after { content: 'üö´'; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 1.2rem;}

        .pat-dots { background-image: url('data:image/svg+xml;utf8,<svg width="20" height="20" xmlns="http://www.w3.org/2000/svg"><circle cx="10" cy="10" r="4" fill="white" opacity="0.8"/></svg>'); }
        .pat-stripes { background-image: url('data:image/svg+xml;utf8,<svg width="20" height="20" xmlns="http://www.w3.org/2000/svg"><path d="M0 20 L20 0 L10 0 L0 10 Z" fill="white" opacity="0.6"/><path d="M10 20 L20 10 L20 20 Z" fill="white" opacity="0.6"/></svg>'); }
        .pat-grid { background-image: url('data:image/svg+xml;utf8,<svg width="20" height="20" xmlns="http://www.w3.org/2000/svg"><path d="M0 0 L20 0 L20 2 L0 2 Z M0 0 L2 0 L2 20 L0 20 Z" fill="white" opacity="0.8"/></svg>'); }
        .pat-check { background-image: url('data:image/svg+xml;utf8,<svg width="20" height="20" xmlns="http://www.w3.org/2000/svg"><rect x="0" y="0" width="10" height="10" fill="white" opacity="0.5"/><rect x="10" y="10" width="10" height="10" fill="white" opacity="0.5"/></svg>'); }
        .pat-zig { background-image: url('data:image/svg+xml;utf8,<svg width="20" height="20" xmlns="http://www.w3.org/2000/svg"><path d="M0 0 L10 10 L20 0 L20 5 L10 15 L0 5 Z" fill="white" opacity="0.6"/></svg>'); }

        input[type="file"] { font-size: 0.8rem; cursor: pointer; color: inherit; width: 100%; }
        input[type="file"]::file-selector-button {
            border: none;
            border-radius: 10px;
            padding: 8px 12px;
            background-color: var(--panel-text);
            color: var(--panel-bg);
            cursor: pointer;
            font-weight: bold;
            margin-right: 10px;
            transition: 0.2s;
            width: 100%;
            margin-bottom: 5px;
        }

        input[type="range"] { width: 100px; cursor: pointer; accent-color: var(--panel-text); }
        input[type="checkbox"] { width: 20px; height: 20px; cursor: pointer; accent-color: var(--panel-text); }
        input[type="color"].mini-picker { width: 30px; height: 30px; padding: 0; border: none; background: none; cursor: pointer; }

        .controls {
            position: fixed;
            bottom: 20px;
            background: var(--panel-bg);
            backdrop-filter: blur(10px);
            padding: 10px 20px;
            border-radius: 50px;
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
            justify-content: center;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            transition: opacity 0.3s ease, transform 0.3s ease, background-color 0.5s ease;
            z-index: 100;
        }

        body.fullscreen-mode .controls { opacity: 0; pointer-events: none; transform: translateY(30px); }
        body.fullscreen-mode.show-controls .controls { opacity: 1; pointer-events: auto; transform: translateY(0); }
        body.fullscreen-mode:not(.show-controls) .settings-panel { opacity: 0 !important; pointer-events: none !important; }
        body.cuber-running .controls, body.cuber-running .settings-panel { opacity: 0 !important; pointer-events: none !important; }

        button {
            padding: 8px 16px;
            border: none;
            border-radius: 20px;
            font-weight: bold;
            cursor: pointer;
            background-color: var(--panel-text);
            color: var(--panel-bg);
            transition: transform 0.1s;
            font-size: 0.9rem;
            min-width: 40px;
        }
        button:active { transform: scale(0.95); }
        input[type="color"] { border: none; width: 35px; height: 35px; cursor: pointer; background: none; padding: 0; }
    </style>
</head>
<body>

    <div class="container">
        <div id="scrambleDisplay" class="scramble-display"></div>
        <h1 id="mainTitle" contenteditable="true" spellcheck="false">My Message</h1>
        <div class="timer-display" id="timer" contenteditable="true" spellcheck="false">05:00</div>
    </div>

    <div id="settingsPanel" class="settings-panel hidden">
        
        <div class="section-title">Visuals & Text</div>
        
        <div style="margin-bottom: 10px;">
            <label style="font-size:0.9rem; font-weight:bold; display:block; margin-bottom:5px;">Font Style:</label>
            <select id="fontSelect" onchange="changeFont()">
                <option value="'Inter', sans-serif">Modern (Inter)</option>
                <option value="'Roboto', sans-serif">Standard (Roboto)</option>
                <option value="'Orbitron', sans-serif">Digital (Orbitron)</option>
                <option value="'JetBrains Mono', monospace">Coding (JetBrains)</option>
                <option value="'Press Start 2P', cursive">Retro (Pixel)</option>
                <option value="'Bangers', cursive">Impact (Bangers)</option>
                <option value="'Lobster', cursive">Fun (Lobster)</option>
                <option value="'Oswald', sans-serif">Bold (Oswald)</option>
                <option value="'Playfair Display', serif">Elegant (Playfair)</option>
                <option value="'Pacifico', cursive">Handwriting (Pacifico)</option>
                <option value="'Caveat', cursive">Marker (Caveat)</option>
            </select>
        </div>

        <div class="toggle-group">
            <div class="toggle-row" onclick="document.getElementById('titleToggle').click()">
                <label>Show Text Message</label>
                <input type="checkbox" id="titleToggle" onchange="toggleTitleVisibility()" onclick="event.stopPropagation()">
            </div>
            <div class="toggle-row" onclick="document.getElementById('msToggle').click()">
                <label>Show Milliseconds</label>
                <input type="checkbox" id="msToggle" onchange="toggleMsVisibility()" onclick="event.stopPropagation()">
            </div>
        </div>

        <div class="section-title" style="margin-top: 10px;">Background Pattern</div>
        <div class="pattern-grid">
            <div class="pattern-btn pat-none" onclick="selectPattern('none')" title="No Pattern"></div>
            <div class="pattern-btn pat-dots" onclick="selectPattern('dots')" title="Dots"></div>
            <div class="pattern-btn pat-stripes" onclick="selectPattern('stripes')" title="Stripes"></div>
            <div class="pattern-btn pat-grid" onclick="selectPattern('grid')" title="Grid"></div>
            <div class="pattern-btn pat-check" onclick="selectPattern('check')" title="Checkers"></div>
            <div class="pattern-btn pat-zig" onclick="selectPattern('zig')" title="ZigZag"></div>
        </div>
        
        <div class="slider-group" style="justify-content: flex-start; gap: 15px;">
            <label>Color:</label>
            <input type="color" id="patColor" class="mini-picker" value="#ffffff" oninput="updatePatternStyle()">
            <label>Opacity:</label>
            <input type="range" id="patOpacity" min="5" max="100" value="20" style="flex-grow:1" oninput="updatePatternStyle()">
        </div>
        <div class="toggle-row" onclick="document.getElementById('blendToggle').click()" style="margin-bottom: 5px;">
            <label>Blend with Background</label>
            <input type="checkbox" id="blendToggle" checked onchange="updatePatternStyle()" onclick="event.stopPropagation()">
        </div>

        <div class="section-title" style="margin-top: 10px;">Background Adjustments</div>
        <div class="slider-group">
            <label>üîç Zoom</label>
            <input type="range" id="bgZoom" min="10" max="200" value="30" oninput="updateBgParams()">
        </div>
        <div class="slider-group">
            <label>‚ÜîÔ∏è Pan X</label>
            <input type="range" id="bgPanX" min="0" max="100" value="50" oninput="updateBgParams()">
        </div>
        <div class="slider-group">
            <label>‚ÜïÔ∏è Pan Y</label>
            <input type="range" id="bgPanY" min="0" max="100" value="50" oninput="updateBgParams()">
        </div>

        <div class="file-upload-group">
            <label>Or Upload Background Image:</label>
            <input type="file" id="bgImageFile" accept="image/*">
        </div>

        <div class="section-title" style="margin-top: 10px;">Modes</div>
        <div class="toggle-row" onclick="document.getElementById('cuberToggle').click()">
            <label title="Hold screen to start">Cuber Mode üßä</label>
            <input type="checkbox" id="cuberToggle" onchange="toggleCuberMode()" onclick="event.stopPropagation()">
        </div>

        <div class="section-title" style="margin-top: 10px;">Audio Levels</div>
        <div class="slider-group">
            <label>üñ±Ô∏è Click</label>
            <input type="range" min="0" max="100" value="30" oninput="volClick = this.value/100; playClick()">
        </div>
        <div class="slider-group">
            <label>‚è±Ô∏è Tick</label>
            <input type="range" min="0" max="100" value="10" oninput="volTick = this.value/100">
        </div>
        <div class="slider-group">
            <label>üîî Alarm</label>
            <input type="range" min="0" max="100" value="50" oninput="volAlarm = this.value/100">
        </div>

        <div class="file-upload-group">
            <label>Custom Alarm Sound:</label>
            <input type="file" id="audioFile" accept="audio/*">
        </div>
    </div>

    <div class="controls">
        <input type="color" id="colorPicker" value="#3498db" title="Change Background Color">
        <button id="toggleBtn" onmousedown="playClick()" onclick="toggleTimer()">Start</button>
        <button onmousedown="playClick()" onclick="resetTimer()">Reset</button>
        <button onmousedown="playClick()" onclick="toggleFullScreen()" title="Fullscreen">‚õ∂</button>
        <button onmousedown="playClick()" onclick="toggleSettings()" title="Settings">‚öôÔ∏è</button>
    </div>

    <script>
        let timeLeft = 300000;
        let originalTime = 300000; 
        let timerInterval;
        let isRunning = false;
        let isEditing = false;
        let isCuberMode = false;
        let holdTimeout;
        let isArmed = false;
        let timerEndTime = 0; 
        let timerStartTime = 0; 
        let lastSecond = 0;

        let currentBgMode = 'none'; 
        let currentPatternType = 'none';

        let volClick = 0.3;
        let volTick = 0.1;
        let volAlarm = 0.5;
        let customAlarmBuffer = null;
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        const audioCtx = new AudioContext();

        const timerDisplay = document.getElementById('timer');
        const mainTitle = document.getElementById('mainTitle');
        const scrambleDisplay = document.getElementById('scrambleDisplay');
        const colorPicker = document.getElementById('colorPicker');
        const toggleBtn = document.getElementById('toggleBtn');
        const settingsPanel = document.getElementById('settingsPanel');
        const audioFileInput = document.getElementById('audioFile');
        const cuberToggle = document.getElementById('cuberToggle');
        const bgImageInput = document.getElementById('bgImageFile');
        
        const sliderZoom = document.getElementById('bgZoom');
        const sliderPanX = document.getElementById('bgPanX');
        const sliderPanY = document.getElementById('bgPanY');
        const patColorInput = document.getElementById('patColor');
        const patOpacityInput = document.getElementById('patOpacity');
        const blendToggle = document.getElementById('blendToggle');
        const fontSelect = document.getElementById('fontSelect');

        function init() {
            updateColors(colorPicker.value);
            changeFont();
            // Sync checkbox state variable
            if(cuberToggle.checked) {
                isCuberMode = true;
                timerDisplay.setAttribute('contenteditable', 'false');
                scrambleDisplay.style.display = 'block';
                generateScramble();
            }
            updateLayout(); 
            updateDisplay();
        }

        function updateColors(hex) {
            document.documentElement.style.setProperty('--bg-color', hex);
            const c = hex.replace("#", "");
            const r = parseInt(c.substr(0,2),16); const g = parseInt(c.substr(2,2),16); const b = parseInt(c.substr(4,2),16);
            const yiq = ((r*299)+(g*587)+(b*114))/1000;
            const contrast = (yiq >= 128) ? '#000000' : '#ffffff';
            
            document.documentElement.style.setProperty('--text-color', contrast);
            const panelBg = (contrast === '#ffffff') ? 'rgba(20, 20, 20, 0.95)' : 'rgba(245, 245, 245, 0.95)';
            const panelText = (contrast === '#ffffff') ? '#ffffff' : '#000000';
            
            document.documentElement.style.setProperty('--panel-bg', panelBg);
            document.documentElement.style.setProperty('--panel-text', panelText);
        }

        colorPicker.addEventListener('input', (e) => updateColors(e.target.value));

        function changeFont() {
            const selectedFont = fontSelect.value;
            document.documentElement.style.setProperty('--current-font', selectedFont);
            if (selectedFont.includes('Press Start 2P')) document.body.classList.add('retro-mode');
            else document.body.classList.remove('retro-mode');
            playClick();
        }

        function hexToRgba(hex, alphaPercent) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            const alpha = alphaPercent / 100;
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }

        function updateBgParams() {
            const zoom = sliderZoom.value;
            const panX = sliderPanX.value;
            const panY = sliderPanY.value;
            document.body.style.backgroundPosition = `${panX}% ${panY}%`;

            if (currentBgMode === 'image') {
                document.body.style.backgroundSize = `${zoom}%`;
            } else if (currentBgMode === 'pattern') {
                document.body.style.backgroundSize = `${zoom}px ${zoom}px`;
            }
        }

        function selectPattern(type) {
            playClick();
            currentBgMode = (type === 'none') ? 'none' : 'pattern';
            currentPatternType = type;
            document.body.classList.remove('custom-image-mode');

            if (type !== 'none') {
                sliderZoom.value = 30;
                sliderPanX.value = 50;
                sliderPanY.value = 50;
            }
            updatePatternStyle(); 
            updateBgParams();     
        }

        function updatePatternStyle() {
            const blend = blendToggle.checked ? 'overlay' : 'normal';
            document.documentElement.style.setProperty('--bg-blend', blend);

            if (currentBgMode === 'image') return; 

            const type = currentPatternType;
            if (type === 'none') {
                document.body.style.backgroundImage = 'none';
                return;
            }

            const hex = patColorInput.value;
            const opacity = patOpacityInput.value;
            const col = hexToRgba(hex, opacity);
            
            let svgContent = '';
            
            if (type === 'dots') {
                svgContent = `<svg width="20" height="20" xmlns="http://www.w3.org/2000/svg"><circle cx="10" cy="10" r="5" fill="${col}"/></svg>`;
            } else if (type === 'stripes') {
                svgContent = `<svg width="20" height="20" xmlns="http://www.w3.org/2000/svg"><path d="M0 20 L20 0 L10 0 L0 10 Z" fill="${col}"/><path d="M10 20 L20 10 L20 20 Z" fill="${col}"/></svg>`;
            } else if (type === 'grid') {
                svgContent = `<svg width="20" height="20" xmlns="http://www.w3.org/2000/svg"><path d="M0 0 L20 0 L20 2 L0 2 Z M0 0 L2 0 L2 20 L0 20 Z" fill="${col}"/></svg>`;
            } else if (type === 'check') {
                svgContent = `<svg width="20" height="20" xmlns="http://www.w3.org/2000/svg"><rect x="0" y="0" width="10" height="10" fill="${col}"/><rect x="10" y="10" width="10" height="10" fill="${col}"/></svg>`;
            } else if (type === 'zig') {
                svgContent = `<svg width="20" height="20" xmlns="http://www.w3.org/2000/svg"><path d="M0 0 L10 10 L20 0 L20 5 L10 15 L0 5 Z" fill="${col}"/></svg>`;
            }

            const encodedSVG = encodeURIComponent(svgContent).replace(/'/g, "%27").replace(/"/g, "'");
            document.body.style.backgroundImage = `url("data:image/svg+xml;utf8,${encodedSVG}")`;
        }

        bgImageInput.addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = function(ev) {
                const url = ev.target.result;
                currentBgMode = 'image';
                sliderZoom.value = 100;
                sliderPanX.value = 50;
                sliderPanY.value = 50;
                document.body.style.backgroundImage = `url("${url}")`;
                document.body.classList.add('custom-image-mode');
                updatePatternStyle(); 
                updateBgParams();
                playClick();
                alert("Background Image Loaded!");
            };
            reader.readAsDataURL(file);
        });

        // --- CORE FUNCTIONS ---
        function updateLayout() {
            const hasTitle = document.getElementById('titleToggle').checked;
            // CHECK MS Toggle OR Cuber Mode
            const showMs = document.getElementById('msToggle').checked || isCuberMode;
            const hasTimer = timerDisplay.innerText.trim() !== "";
            
            mainTitle.style.display = hasTitle ? 'block' : 'none';
            timerDisplay.style.display = hasTimer ? 'inline-block' : 'none';
            
            // This class triggers the smaller font size
            if (showMs) timerDisplay.classList.add('ms-mode');
            else timerDisplay.classList.remove('ms-mode');

            if (hasTitle && hasTimer) {
                timerDisplay.classList.add('shrink-mode');
                mainTitle.classList.remove('solo-mode');
            } else if (!hasTitle && hasTimer) {
                timerDisplay.classList.remove('shrink-mode');
            } else if (hasTitle && !hasTimer) {
                mainTitle.classList.add('solo-mode');
            }
        }

        function updateDisplay() {
            if (isEditing) return;
            const totalSeconds = Math.floor(timeLeft / 1000);
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            const milliseconds = Math.floor((timeLeft % 1000) / 10); 
            let displayString = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            if (document.getElementById('msToggle').checked || isCuberMode) {
                displayString += `.${milliseconds.toString().padStart(2, '0')}`;
            }
            timerDisplay.innerText = displayString;
        }

        function generateScramble() {
            const moves = ['R', 'L', 'U', 'D', 'F', 'B'];
            const modifiers = ['', "'", '2'];
            let scramble = [];
            let lastMove = '';
            for (let i = 0; i < 20; i++) {
                let move;
                do { move = moves[Math.floor(Math.random() * moves.length)]; } while (move === lastMove);
                lastMove = move;
                const modifier = modifiers[Math.floor(Math.random() * modifiers.length)];
                scramble.push(move + modifier);
            }
            scrambleDisplay.textContent = scramble.join(' ');
        }

        function toggleTimer() { isRunning ? pauseTimer() : startTimer(); }
        function startTimer() {
            if (isRunning) return;
            if (audioCtx.state === 'suspended') audioCtx.resume();
            if (isEditing) { parseInputTime(); isEditing = false; }
            isRunning = true;
            toggleBtn.innerText = "Pause";
            lastSecond = Math.floor(timeLeft / 1000);
            const now = Date.now();
            if (isCuberMode) timerStartTime = now - timeLeft;
            else timerEndTime = now + timeLeft;

            timerInterval = setInterval(() => {
                const currentTime = Date.now();
                if (isCuberMode) {
                    timeLeft = currentTime - timerStartTime;
                } else {
                    const remaining = timerEndTime - currentTime;
                    if (remaining > 0) {
                        timeLeft = remaining;
                        const currentSecond = Math.floor(timeLeft / 1000);
                        if (currentSecond < lastSecond) {
                            playTick();
                            lastSecond = currentSecond;
                        }
                    } else {
                        timeLeft = 0;
                        updateDisplay();
                        pauseTimer();
                        playAlarm();
                    }
                }
                updateDisplay();
            }, 10);
        }

        function pauseTimer() {
            clearInterval(timerInterval);
            isRunning = false;
            toggleBtn.innerText = "Start";
        }

        function resetTimer() {
            pauseTimer();
            timeLeft = originalTime;
            if (isCuberMode) { timeLeft = 0; generateScramble(); }
            updateDisplay();
            if(timerDisplay.innerText === "") { updateDisplay(); updateLayout(); }
        }

        function toggleCuberMode() {
            isCuberMode = cuberToggle.checked;
            playClick();
            if(isCuberMode) {
                pauseTimer(); timeLeft = 0; originalTime = 0; generateScramble();
                scrambleDisplay.style.display = 'block'; updateDisplay();
                timerDisplay.setAttribute('contenteditable', 'false');
                alert("Cuber Mode Active:\n1. Hold to Arm\n2. Release to Solve\n3. Tap to Stop");
            } else {
                scrambleDisplay.style.display = 'none';
                timerDisplay.setAttribute('contenteditable', 'true');
                timeLeft = 300000; originalTime = 300000; updateDisplay();
            }
            updateLayout();
        }

        function toggleTitleVisibility() { updateLayout(); playClick(); }
        function toggleMsVisibility() { updateLayout(); updateDisplay(); playClick(); }

        const handleInputDown = (e) => {
            // Check if we are interacting with editable elements (Timer or Title)
            const isEditable = e.target.id === 'timer' || e.target.id === 'mainTitle';
            
            // Standard controls check
            const isControl = e.target.tagName === 'BUTTON' || e.target.tagName === 'INPUT' || e.target.closest('.controls') || e.target.closest('.settings-panel') || e.target.tagName === 'SELECT' || e.target.closest('.toggle-row');
            
            // Fullscreen check logic
            if (document.body.classList.contains('fullscreen-mode') && !isControl && !isRunning && !isEditable) document.body.classList.toggle('show-controls');
            
            // If we are editing, or clicking controls, or NOT in Cuber Mode, let the default behavior happen (keyboard pop up)
            if (!isCuberMode || isControl || (isEditable && !isCuberMode)) return;

            // Cuber Logic below
            e.preventDefault();
            if (isRunning) { pauseTimer(); playClick(); document.body.classList.remove('cuber-running'); generateScramble(); } 
            else { pauseTimer(); timeLeft = 0; updateDisplay(); timerDisplay.classList.add('not-ready'); holdTimeout = setTimeout(() => { timerDisplay.classList.remove('not-ready'); timerDisplay.classList.add('ready'); isArmed = true; playTick(); }, 300); }
        };

        const handleInputUp = (e) => {
            if (!isCuberMode) return;
            clearTimeout(holdTimeout); timerDisplay.classList.remove('not-ready');
            if (isArmed) { timerDisplay.classList.remove('ready'); isArmed = false; startTimer(); document.body.classList.add('cuber-running'); } 
            else { timerDisplay.classList.remove('ready'); }
        };

        document.body.addEventListener('touchstart', handleInputDown, {passive: false});
        document.body.addEventListener('mousedown', handleInputDown);
        document.body.addEventListener('touchend', handleInputUp);
        document.body.addEventListener('mouseup', handleInputUp);

        // --- EXPLICIT FOCUS HANDLER FOR MOBILE ---
        // Some mobile browsers need a direct click listener on the element to pop the keyboard
        const forceFocus = (e) => {
            if(!isCuberMode) {
                e.target.focus();
            }
        };
        timerDisplay.addEventListener('click', forceFocus);
        mainTitle.addEventListener('click', forceFocus);


        function playTone(freq, type, duration, volume) {
            if (volume <= 0) return;
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const osc = audioCtx.createOscillator(); const gainNode = audioCtx.createGain();
            osc.type = type; osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
            gainNode.gain.setValueAtTime(volume, audioCtx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + duration);
            osc.connect(gainNode); gainNode.connect(audioCtx.destination);
            osc.start(); osc.stop(audioCtx.currentTime + duration);
        }
        function playClick() { playTone(800, 'sine', 0.1, volClick); }
        function playTick() { playTone(1000, 'triangle', 0.05, volTick); }
        function playAlarm() {
            if (volAlarm <= 0) return;
            if (audioCtx.state === 'suspended') audioCtx.resume();
            if (customAlarmBuffer) {
                const source = audioCtx.createBufferSource(); const gainNode = audioCtx.createGain();
                source.buffer = customAlarmBuffer; gainNode.gain.value = volAlarm;
                source.connect(gainNode); gainNode.connect(audioCtx.destination); source.start(0);
            } else { playTone(600, 'sine', 1, volAlarm); setTimeout(() => { playTone(400, 'sine', 1.5, volAlarm); }, 400); }
        }

        audioFileInput.addEventListener('change', function(e) {
            const file = e.target.files[0]; if (!file) return;
            const reader = new FileReader();
            reader.onload = function(ev) {
                audioCtx.decodeAudioData(ev.target.result, function(buffer) { customAlarmBuffer = buffer; playClick(); alert("Custom alarm loaded!"); }, function(e) { alert("Error decoding audio."); });
            }; reader.readAsArrayBuffer(file);
        });

        function toggleSettings() { settingsPanel.classList.toggle('hidden'); }

        function toggleFullScreen() {
            settingsPanel.classList.add('hidden');
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().catch((err) => console.log(err));
            } else {
                if (document.exitFullscreen) { document.exitFullscreen(); }
            }
        }

        document.addEventListener('fullscreenchange', () => {
            if (!document.fullscreenElement) {
                document.body.classList.remove('fullscreen-mode');
                document.body.classList.remove('show-controls');
            } else {
                document.body.classList.add('fullscreen-mode');
                document.body.classList.remove('show-controls');
            }
        });

        timerDisplay.addEventListener('focus', () => { if(isCuberMode) { timerDisplay.blur(); return; } isEditing = true; pauseTimer(); });
        timerDisplay.addEventListener('blur', () => { 
            if(isCuberMode) return;
            let text = timerDisplay.innerText.trim();
            if (text === "") { updateLayout(); isEditing = false; return; }
            let seconds = 0;
            if (text.includes(':')) { const parts = text.split(':'); const mins = parseInt(parts[0]) || 0; const secPart = parseFloat(parts[1]) || 0; seconds = (mins * 60) + secPart; } 
            else { seconds = parseFloat(text) || 0; }
            timeLeft = Math.floor(seconds * 1000); originalTime = timeLeft; isEditing = false; updateDisplay(); updateLayout();
        });
        timerDisplay.addEventListener('keydown', (e) => { if (e.key === 'Enter') { e.preventDefault(); timerDisplay.blur(); } });

        window.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
